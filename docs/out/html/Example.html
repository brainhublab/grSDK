<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GR SDK: $title</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GR SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="expage"></a></p>
<h1><a class="anchor" id="example"></a>
How to Use this Extended Kalman Filter Library?</h1>
<h2><a class="anchor" id="introduction"></a>
Introduction</h2>
<p>This Extended Kalman Filter library is powerful and very simple to use, but a Kalman filter is very difficult to debug. So, it is very important to follow a procedure to be sure that everything is right (code and equations). This example suggests a procedure to follow and shows how to use the library. If you are not familiar with the Kalman filter, please read this article [02].</p>
<h2><a class="anchor" id="step1"></a>
Step 1 : Find the mathematical model of the system</h2>
<p>The first thing to do is to find out the state vector you want to estimate <img class="formulaInl" alt="$ \vec x $" src="form_0.png"/> and the inputs <img class="formulaInl" alt="$ \vec u $" src="form_1.png"/> of the system. After this, find the non-linear process function <img class="formulaInl" alt="$ f $" src="form_2.png"/> that describes the evolution of the state vector through time, that is : </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \vec x_k = f \left( x_{k-1}, u_{k-1}, w_{k-1} \right) \]" src="form_3.png"/>
</p>
<p> where <img class="formulaInl" alt="$ w $" src="form_4.png"/> is the process noise vector due to uncertainty and process modeling errors.</p>
<p>Then, find the non-linear relation between your state vector <img class="formulaInl" alt="$ \vec x $" src="form_0.png"/> and the measure vector <img class="formulaInl" alt="$ \vec z $" src="form_5.png"/>. </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \vec z_k = h \left( x_{k-1}, v_{k-1} \right) \]" src="form_6.png"/>
</p>
<p> where <img class="formulaInl" alt="$ v $" src="form_7.png"/> is the measure noise vector.</p>
<dl class="section user"><dt>In this example :</dt><dd></dd></dl>
<p>A plane flies in a 2D space where the x axis is the distance traveled by the plane and y axis is its altitude. This system can be represented by the following continuous equations:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \ddot x = \frac{u}{m} - \frac{b_x}{m} \dot x^{2} \]" src="form_8.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \ddot y = \frac{p}{m} \dot x^{2} - g \]" src="form_9.png"/>
</p>
<p>where <img class="formulaInl" alt="$ m $" src="form_10.png"/> is the plane's weight (1000 kg)<br />
 <img class="formulaInl" alt="$ b_{x} $" src="form_11.png"/> is the drag coefficient (0.35 N/m²/s²)<br />
 <img class="formulaInl" alt="$ p $" src="form_12.png"/> is the lift force (3.92 N/m²/s²)<br />
 <img class="formulaInl" alt="$ g $" src="form_13.png"/> is the gravitational acceleration (9.8 m/s²)<br />
 <img class="formulaInl" alt="$ u $" src="form_14.png"/> (the input) is the motor's thrust<br />
 The discrete equation is: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\vec x_k = \left [ \begin{array}{c} x_k \\ \\ \dot x_k \\ \\ y_k \\ \\ \dot y_k \end{array} \right] = //! \left [ \begin{array}{c} //! x_{k-1} + T \dot x_{k-1} + \frac{T^{2}}{2} \left( \frac{u}{m} - \frac{b_x}{m} \dot x_{k-1}^{2} \right )\\ \\ //! \dot x_{k-1} + T \left ( \frac{u}{m} - \frac{b_x}{m} \dot x_{k-1}^{2} \right ) + w_{1} \\ \\ //! y_{k-1} + T \dot y_{k-1} + \frac{T^{2}}{2} \left( \frac{p}{m} \dot x_{k-1}^{2} - g \right )\\ \\ //! \dot y_{k-1} + T \left( \frac{p}{m} \dot x_{k-1}^{2} - g \right ) + w_{2} //! \end{array} \right ] \]" src="form_15.png"/>
</p>
<p>where <img class="formulaInl" alt="$ w_{1} $" src="form_16.png"/> and <img class="formulaInl" alt="$ w_{2} $" src="form_17.png"/> are the random variables which represent the process noise.</p>
<p>A station on the ground (at the origin) mesures the angle between the plane and the ground (x axis) and the distance between the plane and the station. These measures are based on the following equation:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\vec z_k = \left [ \begin{array}{c} \theta \\ \\ r \end{array} \right ] = //! \left [ \begin{array}{c} atan(\frac{y}{x}) +v_{1} \\ \\ \sqrt{x^{2}+y^{2}} + v_{2} \end{array} \right ] \]" src="form_18.png"/>
</p>
<p>where <img class="formulaInl" alt="$ v_{1} $" src="form_19.png"/> and <img class="formulaInl" alt="$ v_{2} $" src="form_20.png"/> are the random variables which represent the process noise.</p>
<h2><a class="anchor" id="step2"></a>
Step 2 : Calculate Jacobian matrix</h2>
<p>Calculate the jacobian matrix A, W, H and V where : A is an <em>n</em> by <em>n</em> jacobian matrix of partial derivatives, defined as follow : </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ A_{[i,j]} = \frac{\partial f_{[i]}}{\partial x_{[j]}} \]" src="form_21.png"/>
</p>
<p>W is an <em>n</em> by <em>nv</em> jacobian matrix of partial derivatives, defined as follow : </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ W_{[i,j]} = \frac{\partial f_{[i]}}{\partial w_{[j]}} \]" src="form_22.png"/>
</p>
<p>H is an <em>m</em> by <em>n</em> jacobian matrix of partial derivatives, defined as follow : </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ H_{[i,j]} = \frac{\partial h_{[i]}}{\partial x_{[j]}} \]" src="form_23.png"/>
</p>
<p>V is an <em>m</em> by <em>nv</em> jacobian matrix of partial derivatives, defined as follow : </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ V_{[i,j]} = \frac{\partial h_{[i]}}{\partial v_{[j]}} \]" src="form_24.png"/>
</p>
<p><img class="formulaInl" alt="$ n $" src="form_25.png"/> is the number of element in state vector<br />
 <img class="formulaInl" alt="$ m $" src="form_10.png"/> is the number of measure<br />
 <img class="formulaInl" alt="$ nw $" src="form_26.png"/> is the number of process noise random variables<br />
 <img class="formulaInl" alt="$ nv $" src="form_27.png"/> is the number of measure noise random variables<br />
 </p><dl class="section user"><dt>In this example:</dt><dd></dd></dl>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = \left [ \begin{array}{cccc} //! 1 &amp; T-T^{2} \frac{b}{m} \dot x_{k-1} &amp; 0 &amp; 0 \\ \\ //! 0 &amp; 1-2T \frac{b}{m} \dot x_{k-1} &amp; 0 &amp; 0 \\ \\ //! 0 &amp; T^{2} \frac{p}{m} \dot x_{k-1} &amp; 1 &amp; T \\ \\ //! 0 &amp; 2T \frac{p}{m} \dot x_{k-1} &amp; 0 &amp; 1 //! \end{array} \right ] \]" src="form_28.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ W = \left [ \begin{array}{cc} //! 0 &amp; 0 \\ \\ //! 1 &amp; 0 \\ \\ //! 0 &amp; 0\\ \\ //! 0 &amp; 1 //! \end{array} \right ] \]" src="form_29.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ H = \left [ \begin{array}{cccc} //! \frac{- \dot y_{k-1}}{x_{k-1}^{2}+y_{k-1}^{2}} &amp; 0 \frac{ \dot x_{k-1}}{x_{k-1}^{2}+y_{k-1}^{2}} &amp; 0 \\ \\ //! \frac{ \dot x_{k-1}}{\sqrt{x_{k-1}^{2}+y_{k-1}^{2}}} &amp; 0 \frac{ \dot y_{k-1}}{\sqrt{x_{k-1}^{2}+y_{k-1}^{2}}} &amp; 0 //! \end{array} \right ] \]" src="form_30.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ V = \left [ \begin{array}{cc} //! 1 &amp; 0 \\ \\ //! 0 &amp; 1 //! \end{array} \right ] \]" src="form_31.png"/>
</p>
<h2><a class="anchor" id="step3"></a>
Step 3 : Initial conditions and covariance matrix</h2>
<pre class="fragment">Set initial estimation of the state vector. After, set the covariance matrix P 
which represents the covariance of the error of the state vector estimation. 
Then, set the covariance Q and R which represent the covariance matrix
of process noise and measurement noise, respectively.

\par In this example:

The first estimation of the state vector is based on the first measures and the covariance matrix are the following:
</pre><p class="formulaDsp">
<img class="formulaDsp" alt="\[\vec x = \left [ \begin{array}{c} r\cos\theta \\ 60 \\ r\sin\theta \\ 0 \end{array} \right] \]" src="form_32.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ P = \left [ \begin{array}{cccc} //! 100^2 &amp; 0 &amp; 0 &amp; 0 \\ \\ //! 0 &amp; 10^2 &amp; 0 &amp; 0 \\ \\ //! 0 &amp; 0 &amp; 25^2 &amp; 0 \\ \\ //! 0 &amp; 0 &amp; 0 &amp; 10^2 \\ \\ //! \end{array} \right ] \]" src="form_33.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Q = \left [ \begin{array}{cc} //! 0.01^{2} &amp; 0.01^{2}/10 \\ \\ //! 0.01^{2}/10 &amp; 0.01^{2} //! \end{array} \right ] \]" src="form_34.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ R = \left [ \begin{array}{cc} //! 0.01^{2} &amp; 0 \\ \\ //! 0 &amp; 0.01^{2} //! \end{array} \right ] \]" src="form_35.png"/>
</p>
<h2><a class="anchor" id="step4"></a>
Step 4 : Implementation of the Kalman filter</h2>
<pre class="fragment">Now, it's time to create the first version of your %Kalman filter. 
You should not try to optimize it at this step, just create your filter and validate it.
This library allows you to optimize your filter, but in your first implementation, 
code only the basic functions.  So, code functions called \c makeProcess(), \c makeMeasure(), 
\c makeA(), \c makeH(), \c makeQ(), \c makeR(), \c makeV() and \c makeW(). These functions will set the value of each matrix.

The first thing to do is to create your %Kalman filter class.

\dontinclude simple_plane.h
\skip class
\until }

In this example, our %Kalman filter inherits from the Extended %Kalman Filter, because it's a non-linear problem ( \form#2 and \form#36 are non-linear functions)
The first two template parameters are respectively the floating point type used by the filter (\c float or \c double) and the beginning index
of vectors and matrices (0 or 1). There are three other template parameters to the \c EKFilter template class. 
They are explained in the next section, but they
can be safely set to their default values in the first version of the filter, which are false, false and true to 
disable optimizations and enable bound-checking.

You should declare each functions named previously in this class. You can declare variables too.

After, code the class constructor. You can call the function \c setDim() here or you will call it manually
in your \c main() function after you created the filter object.  The function \c setDim() sets the number of states,
the number of inputs, the number of process noise random variables, the number of measures and the 
number of measurement noise random variables. It can be used by advanced users to implement a
Variable-Dimension Extended %Kalman Filter (an EKF whose dimensions may change from one iteration to the other).

\dontinclude simple_plane.cpp
\skip cPlaneEKF::cPlaneEKF
\until }

In the function \c makeProcess(), you should use a temporary vector to store the new state vector like this :

\skip cPlaneEKF::makeProcess
\until }

In the function \c makeMeasure(), you update directly the measures vector \form#5.  These are the predicted measures.

\skip cPlaneEKF::makeMeasure
\until }

Then, you code all other functions \c makeX() like this:

\dontinclude simple_plane.cpp
\skip cPlaneEKF::makeA
\until }

\skip cPlaneEKF::makeW
\until }

\skip cPlaneEKF::makeQ
\until }

\skip cPlaneEKF::makeH
\until }

\skip cPlaneEKF::makeV
\until }

\skip cPlaneEKF::makeR
\until }

Now, your filter is ready to be used.  In this example, the measures and the inputs
have been calculated by the \c generation.m Matlab script. It's a good idea to test 
your filter with fixed measures and inputs if you want to validate it.

After you create the filter object, you should call the \c setDim() function before calling the \c init() function.
In this example, the \c setDim() function is called in the class constructor.  The \c init() function 
sets the initial state and the initial covariance matrix. 

WARNING : The vectors passed to the \c init() function become unusable when \c init() returns ! Never use those vectors after the call.

\dontinclude example.cpp
\skip cPlaneEKF
\until };

\skip Initial
\until init

\skip for
\until }

Call the function \c step() for each iteration and pass the new inputs and the new measures. 
</pre><h2><a class="anchor" id="step5"></a>
Step 5 : Optimization</h2>
<pre class="fragment">When your %Kalman filter works properly, you can optimize it in many simple ways.

-# If matrix Q is always diagonal, set the OQ template parameter to \c true. This will
minimize some calculations. Also, you will only need to fill in diagonal elements of Q,
since the other values will never be read.
-# If both matrices V and R are always diagonal, set the OVR template parameter to \c true. This will
minimize some calculations. Also, you will only need to fill in diagonal elements of V and R,
since the other values will never be read.
-# If some matrix values are constant, use the \c makeBaseX() function instead of the \c makeX() function
to fill these values.
These functions are called only once at the beginning instead of once per iteration. You can used 
the \c makeBaseX() function to set values that never change in a matrix and just set the other
values in the \c makeX() function.
-# If complex calculations are needed for more than one of \c makeA(), \c makeW(), \c makeQ() and \c makeProcess()
functions, then use the function \c makeCommonProcess() to do those calculations and save them in member variables of your own subclass.  This function is
always called before the others.
-# If complex calculations are needed for more than one of \c makeH(), \c makeV(), \c makeR(), \c makeMeasure()
and \c makeDZ() functions, then use the function \c makeCommonMeasure() to do those calculations and save them in member variables of your own subclass.  This function is
always called before the others.
-# While writing a \c makeX() or a \c makeBaseX() function, there can be some execution paths where the function
does not modify any matrix (for example, if there is some condition, then modify the matrix, else don't).
If this is the case, then each non-mutating execution path should call \c NoModification() before returning,
so that some calculations can be avoided.
-# When your filter works properly, set the debug template parameter to \c false to disable bound-checking.

\par In this example:

This example have been optimized in many ways:

- The matrices V and R are diagonal, so the OVR template parameter is set to true.  Then, we just have to 
set the diagonal values of those matrices.
- The matrices V, R, W and Q never change, so we use \c makeBaseX() functions instead of \c makeX() functions.
- Constants values of A and H have been moved from the \c makeX() functions to \c makeBaseX() functions.
- The filter works properly, so we don't need bound-checking. Let's set the debug template parameter to \c false.

So, the final result for this example is:

\include plane.h

\include plane.cpp
</pre><h1><a class="anchor" id="reference"></a>
References</h1>
<p>[01] Bierman, G. J. "Factorization Methods for Discrete Sequential
    Estimation", Academic Press, 1977. <br />
 [02] Welch, G. and Bishop, G. "An Introduction to the %Kalman Filter", <a href="http://www.cs.unc.edu/~welch/kalman/kalmanIntro.html">http://www.cs.unc.edu/~welch/kalman/kalmanIntro.html</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
