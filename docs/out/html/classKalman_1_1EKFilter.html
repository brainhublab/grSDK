<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GR SDK: Kalman::EKFilter&lt; T, BEG, OQ, OVR, DBG &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GR SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceKalman.html">Kalman</a></li><li class="navelem"><a class="el" href="classKalman_1_1EKFilter.html">EKFilter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classKalman_1_1EKFilter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Kalman::EKFilter&lt; T, BEG, OQ, OVR, DBG &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Generic Extended Kalman Filter (EKF) template base class.  
 <a href="classKalman_1_1EKFilter.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ekfilter_8hpp_source.html">ekfilter.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Kalman::EKFilter&lt; T, BEG, OQ, OVR, DBG &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classKalman_1_1EKFilter.png" usemap="#Kalman::EKFilter_3C_20T_2C_20BEG_2C_20OQ_2C_20OVR_2C_20DBG_20_3E_map" alt=""/>
  <map id="Kalman::EKFilter_3C_20T_2C_20BEG_2C_20OQ_2C_20OVR_2C_20DBG_20_3E_map" name="Kalman::EKFilter_3C_20T_2C_20BEG_2C_20OQ_2C_20OVR_2C_20DBG_20_3E_map">
<area href="classKalman_1_1KFilter.html" title="Generic Linear Kalman Filter template base class. " alt="Kalman::KFilter&lt; T, BEG, OQ, OVR, DBG &gt;" shape="rect" coords="0,56,269,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0665fa7fa760b5235cb556e2503ff687"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classKalman_1_1EKFilter.html#a0665fa7fa760b5235cb556e2503ff687aa3adf9ec22ed3a246105276c85a146c1">beg</a> = BEG
 }</td></tr>
<tr class="separator:a0665fa7fa760b5235cb556e2503ff687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851a633529f2cd75991b1858407011cd"><td class="memItemLeft" align="right" valign="top"><a id="a851a633529f2cd75991b1858407011cd"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a851a633529f2cd75991b1858407011cd">type</a></td></tr>
<tr class="memdesc:a851a633529f2cd75991b1858407011cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of objects contained in matrices and vectors. <br /></td></tr>
<tr class="separator:a851a633529f2cd75991b1858407011cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af773d1217ecb01925b857d49b32bc636"><td class="memItemLeft" align="right" valign="top"><a id="af773d1217ecb01925b857d49b32bc636"></a>
typedef <a class="el" href="classKalman_1_1KVector.html">KVector</a>&lt; T, BEG, DBG &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#af773d1217ecb01925b857d49b32bc636">Vector</a></td></tr>
<tr class="memdesc:af773d1217ecb01925b857d49b32bc636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector type. <br /></td></tr>
<tr class="separator:af773d1217ecb01925b857d49b32bc636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cbc4cb4d9139a7f241b27110426af43"><td class="memItemLeft" align="right" valign="top"><a id="a7cbc4cb4d9139a7f241b27110426af43"></a>
typedef <a class="el" href="classKalman_1_1KMatrix.html">KMatrix</a>&lt; T, BEG, DBG &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a7cbc4cb4d9139a7f241b27110426af43">Matrix</a></td></tr>
<tr class="memdesc:a7cbc4cb4d9139a7f241b27110426af43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix type. <br /></td></tr>
<tr class="separator:a7cbc4cb4d9139a7f241b27110426af43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a80d5dc8f46e8f5d4ec3a6b1e804fdc9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a80d5dc8f46e8f5d4ec3a6b1e804fdc9f">init</a> (<a class="el" href="classKalman_1_1EKFilter.html#af773d1217ecb01925b857d49b32bc636">Vector</a> &amp;x_, <a class="el" href="classKalman_1_1EKFilter.html#a7cbc4cb4d9139a7f241b27110426af43">Matrix</a> &amp;P_)</td></tr>
<tr class="memdesc:a80d5dc8f46e8f5d4ec3a6b1e804fdc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets initial conditions for the Kalman Filter.  <a href="#a80d5dc8f46e8f5d4ec3a6b1e804fdc9f">More...</a><br /></td></tr>
<tr class="separator:a80d5dc8f46e8f5d4ec3a6b1e804fdc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructor and Destructor.</div></td></tr>
<tr class="memitem:a448c107f8f22cc8b041d34d785dd2a58"><td class="memItemLeft" align="right" valign="top"><a id="a448c107f8f22cc8b041d34d785dd2a58"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a448c107f8f22cc8b041d34d785dd2a58">EKFilter</a> ()</td></tr>
<tr class="memdesc:a448c107f8f22cc8b041d34d785dd2a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a448c107f8f22cc8b041d34d785dd2a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0ddc0f02fe2064481400de28a27fde"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#aaf0ddc0f02fe2064481400de28a27fde">EKFilter</a> (<a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a> n_, <a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a> nu_, <a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a> nw_, <a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a> m_, <a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a> nv_)</td></tr>
<tr class="memdesc:aaf0ddc0f02fe2064481400de28a27fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructors specifying all necessary matrix and vector dimensions.  <a href="#aaf0ddc0f02fe2064481400de28a27fde">More...</a><br /></td></tr>
<tr class="separator:aaf0ddc0f02fe2064481400de28a27fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeabe4165de52b77d480a6cbe5f2ac572"><td class="memItemLeft" align="right" valign="top"><a id="aeabe4165de52b77d480a6cbe5f2ac572"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#aeabe4165de52b77d480a6cbe5f2ac572">~EKFilter</a> ()</td></tr>
<tr class="memdesc:aeabe4165de52b77d480a6cbe5f2ac572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor. <br /></td></tr>
<tr class="separator:aeabe4165de52b77d480a6cbe5f2ac572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dimension Accessor Functions</div></td></tr>
<tr class="memitem:a949674c33d413ba357b5818844ade83a"><td class="memItemLeft" align="right" valign="top"><a id="a949674c33d413ba357b5818844ade83a"></a>
<a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a949674c33d413ba357b5818844ade83a">getSizeX</a> () const</td></tr>
<tr class="memdesc:a949674c33d413ba357b5818844ade83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the state vector. <br /></td></tr>
<tr class="separator:a949674c33d413ba357b5818844ade83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af767738a6535ed55fd5eeaef2be0711f"><td class="memItemLeft" align="right" valign="top"><a id="af767738a6535ed55fd5eeaef2be0711f"></a>
<a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#af767738a6535ed55fd5eeaef2be0711f">getSizeU</a> () const</td></tr>
<tr class="memdesc:af767738a6535ed55fd5eeaef2be0711f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the input vector. <br /></td></tr>
<tr class="separator:af767738a6535ed55fd5eeaef2be0711f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8274cbce6b66f6d5c636b9d0cf2073d7"><td class="memItemLeft" align="right" valign="top"><a id="a8274cbce6b66f6d5c636b9d0cf2073d7"></a>
<a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a8274cbce6b66f6d5c636b9d0cf2073d7">getSizeW</a> () const</td></tr>
<tr class="memdesc:a8274cbce6b66f6d5c636b9d0cf2073d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the process noise vector. <br /></td></tr>
<tr class="separator:a8274cbce6b66f6d5c636b9d0cf2073d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3353ebb63c6aecdf6ed33827ca51d1"><td class="memItemLeft" align="right" valign="top"><a id="a3c3353ebb63c6aecdf6ed33827ca51d1"></a>
<a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a3c3353ebb63c6aecdf6ed33827ca51d1">getSizeZ</a> () const</td></tr>
<tr class="memdesc:a3c3353ebb63c6aecdf6ed33827ca51d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the measurement vector. <br /></td></tr>
<tr class="separator:a3c3353ebb63c6aecdf6ed33827ca51d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b34d010e5de11f2609abef2ffed50e2"><td class="memItemLeft" align="right" valign="top"><a id="a1b34d010e5de11f2609abef2ffed50e2"></a>
<a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a1b34d010e5de11f2609abef2ffed50e2">getSizeV</a> () const</td></tr>
<tr class="memdesc:a1b34d010e5de11f2609abef2ffed50e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the measurement noise vector. <br /></td></tr>
<tr class="separator:a1b34d010e5de11f2609abef2ffed50e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Resizing Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions allow to change the dimensions of all matrices and vectors, thus implementing a Variable-Dimension Extended Kalman Filter. They do nothing if the new size is the same as the old one. </p><dl class="section warning"><dt>Warning</dt><dd><code><a class="el" href="classKalman_1_1EKFilter.html#a0c311fd7fc6d57c206029ea0e902cf2e" title="Sets all dimensions at once. ">setDim()</a></code> (or the five <code>setSize</code> functions) <b>must</b> be called <b>before</b> any other function, or else, matrices and vectors will not have their memory allocated. </dd></dl>
</div></td></tr>
<tr class="memitem:a0c311fd7fc6d57c206029ea0e902cf2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a0c311fd7fc6d57c206029ea0e902cf2e">setDim</a> (<a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a> n_, <a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a> nu_, <a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a> nw_, <a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a> m_, <a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a> nv_)</td></tr>
<tr class="memdesc:a0c311fd7fc6d57c206029ea0e902cf2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all dimensions at once.  <a href="#a0c311fd7fc6d57c206029ea0e902cf2e">More...</a><br /></td></tr>
<tr class="separator:a0c311fd7fc6d57c206029ea0e902cf2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c56983458ab0d3dca1a855baee71280"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a9c56983458ab0d3dca1a855baee71280">setSizeX</a> (<a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a> n_)</td></tr>
<tr class="memdesc:a9c56983458ab0d3dca1a855baee71280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the state vector.  <a href="#a9c56983458ab0d3dca1a855baee71280">More...</a><br /></td></tr>
<tr class="separator:a9c56983458ab0d3dca1a855baee71280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012ca0bbb28a1a4ea93a8ff0f5f07f20"><td class="memItemLeft" align="right" valign="top"><a id="a012ca0bbb28a1a4ea93a8ff0f5f07f20"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a012ca0bbb28a1a4ea93a8ff0f5f07f20">setSizeU</a> (<a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a> nu_)</td></tr>
<tr class="memdesc:a012ca0bbb28a1a4ea93a8ff0f5f07f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the input vector. <br /></td></tr>
<tr class="separator:a012ca0bbb28a1a4ea93a8ff0f5f07f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6518bb07784ffd30edc70750ec0459f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a6518bb07784ffd30edc70750ec0459f1">setSizeW</a> (<a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a> nw_)</td></tr>
<tr class="memdesc:a6518bb07784ffd30edc70750ec0459f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the process noise vector.  <a href="#a6518bb07784ffd30edc70750ec0459f1">More...</a><br /></td></tr>
<tr class="separator:a6518bb07784ffd30edc70750ec0459f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e88c8ef5bb4b75c8f287aa6b9a4f13"><td class="memItemLeft" align="right" valign="top"><a id="a11e88c8ef5bb4b75c8f287aa6b9a4f13"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a11e88c8ef5bb4b75c8f287aa6b9a4f13">setSizeZ</a> (<a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a> m_)</td></tr>
<tr class="memdesc:a11e88c8ef5bb4b75c8f287aa6b9a4f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the measurement vector. <br /></td></tr>
<tr class="separator:a11e88c8ef5bb4b75c8f287aa6b9a4f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac32c8a2321ce673395442d54c436d1a"><td class="memItemLeft" align="right" valign="top"><a id="aac32c8a2321ce673395442d54c436d1a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#aac32c8a2321ce673395442d54c436d1a">setSizeV</a> (<a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a> nv_)</td></tr>
<tr class="memdesc:aac32c8a2321ce673395442d54c436d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the measurement noise vector. <br /></td></tr>
<tr class="separator:aac32c8a2321ce673395442d54c436d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Kalman Filter Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions allow to get the results from the Kalman filtering algorithm. Before any of these can be called, all dimensions must have been set properly at least once and <code><a class="el" href="classKalman_1_1EKFilter.html#a80d5dc8f46e8f5d4ec3a6b1e804fdc9f" title="Sets initial conditions for the Kalman Filter. ">init()</a></code> must have been called, also at least once. Each time the user want to resize some vectors, the corresponding resizing functions must be called again before being able to call one of the functions in this section. <code><a class="el" href="classKalman_1_1EKFilter.html#a80d5dc8f46e8f5d4ec3a6b1e804fdc9f" title="Sets initial conditions for the Kalman Filter. ">init()</a></code> must also be called again if <em>n</em> or <em>nw</em> has changed. <code><a class="el" href="classKalman_1_1EKFilter.html#a80d5dc8f46e8f5d4ec3a6b1e804fdc9f" title="Sets initial conditions for the Kalman Filter. ">init()</a></code> can also be called solely to reset the filter. </p>
</div></td></tr>
<tr class="memitem:ac481300c7de95accb6d3705ee93cb35f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#ac481300c7de95accb6d3705ee93cb35f">step</a> (<a class="el" href="classKalman_1_1EKFilter.html#af773d1217ecb01925b857d49b32bc636">Vector</a> &amp;u_, const <a class="el" href="classKalman_1_1EKFilter.html#af773d1217ecb01925b857d49b32bc636">Vector</a> &amp;z_)</td></tr>
<tr class="memdesc:ac481300c7de95accb6d3705ee93cb35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes one prediction-correction step.  <a href="#ac481300c7de95accb6d3705ee93cb35f">More...</a><br /></td></tr>
<tr class="separator:ac481300c7de95accb6d3705ee93cb35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715d9c634db18e24579673f426750e36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a715d9c634db18e24579673f426750e36">timeUpdateStep</a> (<a class="el" href="classKalman_1_1EKFilter.html#af773d1217ecb01925b857d49b32bc636">Vector</a> &amp;u_)</td></tr>
<tr class="memdesc:a715d9c634db18e24579673f426750e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes one prediction step.  <a href="#a715d9c634db18e24579673f426750e36">More...</a><br /></td></tr>
<tr class="separator:a715d9c634db18e24579673f426750e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c2889b2229cb815f9e4b10b0402110"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a01c2889b2229cb815f9e4b10b0402110">measureUpdateStep</a> (const <a class="el" href="classKalman_1_1EKFilter.html#af773d1217ecb01925b857d49b32bc636">Vector</a> &amp;z_)</td></tr>
<tr class="memdesc:a01c2889b2229cb815f9e4b10b0402110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes one correction step.  <a href="#a01c2889b2229cb815f9e4b10b0402110">More...</a><br /></td></tr>
<tr class="separator:a01c2889b2229cb815f9e4b10b0402110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f50329514f21971663ae6d4a26a1bb6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classKalman_1_1EKFilter.html#af773d1217ecb01925b857d49b32bc636">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a5f50329514f21971663ae6d4a26a1bb6">predict</a> (<a class="el" href="classKalman_1_1EKFilter.html#af773d1217ecb01925b857d49b32bc636">Vector</a> &amp;u_)</td></tr>
<tr class="memdesc:a5f50329514f21971663ae6d4a26a1bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the predicted state vector (<em>a priori</em> state estimate).  <a href="#a5f50329514f21971663ae6d4a26a1bb6">More...</a><br /></td></tr>
<tr class="separator:a5f50329514f21971663ae6d4a26a1bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae111e647e38f64bed354c85ff8f5c3ad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classKalman_1_1EKFilter.html#af773d1217ecb01925b857d49b32bc636">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#ae111e647e38f64bed354c85ff8f5c3ad">simulate</a> ()</td></tr>
<tr class="memdesc:ae111e647e38f64bed354c85ff8f5c3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the predicted measurement vector.  <a href="#ae111e647e38f64bed354c85ff8f5c3ad">More...</a><br /></td></tr>
<tr class="separator:ae111e647e38f64bed354c85ff8f5c3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139a2b78cca2fdd1f8d98998608385b0"><td class="memItemLeft" align="right" valign="top"><a id="a139a2b78cca2fdd1f8d98998608385b0"></a>
const <a class="el" href="classKalman_1_1EKFilter.html#af773d1217ecb01925b857d49b32bc636">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a139a2b78cca2fdd1f8d98998608385b0">getX</a> () const</td></tr>
<tr class="memdesc:a139a2b78cca2fdd1f8d98998608385b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the corrected state (<em>a posteriori</em> state estimate). <br /></td></tr>
<tr class="separator:a139a2b78cca2fdd1f8d98998608385b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73c892e9624013167ddecc04be01044"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classKalman_1_1EKFilter.html#a7cbc4cb4d9139a7f241b27110426af43">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#af73c892e9624013167ddecc04be01044">calculateP</a> () const</td></tr>
<tr class="memdesc:af73c892e9624013167ddecc04be01044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <em>a posteriori</em> error covariance estimate matrix.  <a href="#af73c892e9624013167ddecc04be01044">More...</a><br /></td></tr>
<tr class="separator:af73c892e9624013167ddecc04be01044"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae3350773ed390892c2dd6dfe9dfbca89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#ae3350773ed390892c2dd6dfe9dfbca89">NoModification</a> ()</td></tr>
<tr class="memdesc:ae3350773ed390892c2dd6dfe9dfbca89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows optimizations on some calculations.  <a href="#ae3350773ed390892c2dd6dfe9dfbca89">More...</a><br /></td></tr>
<tr class="separator:ae3350773ed390892c2dd6dfe9dfbca89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d12c3635dfb60459b214fb57167bc1"><td class="memItemLeft" align="right" valign="top"><a id="a63d12c3635dfb60459b214fb57167bc1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a63d12c3635dfb60459b214fb57167bc1">sizeUpdate</a> ()</td></tr>
<tr class="memdesc:a63d12c3635dfb60459b214fb57167bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes all vector and matrices. <b>Never</b> call or overload this ! <br /></td></tr>
<tr class="separator:a63d12c3635dfb60459b214fb57167bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrix Pre-Creators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Theses functions have been designed to be overridden by derived classes if necessary. Their role is to fill in the parts of the Kalman matrices that don't change between iterations. That is to say, these functions should only set constant values inside matrices that don't depend on <em>x</em> or <em>u</em>.</p>
<p>They will all be called at least once, before the calls to their corresponding matrix (not pre-) creators. In fact, they are called once per resize (not necessarily at the moment of the resize though), including while the matrices are first allocated.</p>
<dl class="section note"><dt>Note</dt><dd>Matrices have already been properly resized before these functions are called, so no further resizing is or should be necessary. </dd>
<dd>
If a matrix pre-creator is overridden, but it does not modify in any way the matrix in certain execution paths, then the function <code><a class="el" href="classKalman_1_1EKFilter.html#ae3350773ed390892c2dd6dfe9dfbca89" title="Allows optimizations on some calculations. ">NoModification()</a></code> should be called in each of those execution paths so that the filter can optimize away some calculations. The default versions of the matrix pre-creators only call <code><a class="el" href="classKalman_1_1EKFilter.html#ae3350773ed390892c2dd6dfe9dfbca89" title="Allows optimizations on some calculations. ">NoModification()</a></code> in their bodies. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Each matrix pre-creator cannot suppose that any other matrix pre-creator will be called before or after it. </dd></dl>
</div></td></tr>
<tr class="memitem:af3eb4846dcdeaf39ab8f54624588a565"><td class="memItemLeft" align="right" valign="top"><a id="af3eb4846dcdeaf39ab8f54624588a565"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#af3eb4846dcdeaf39ab8f54624588a565">makeBaseA</a> ()</td></tr>
<tr class="memdesc:af3eb4846dcdeaf39ab8f54624588a565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual pre-creator of <em>A</em>. <br /></td></tr>
<tr class="separator:af3eb4846dcdeaf39ab8f54624588a565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6668b0ffe41e701cc44337546d233465"><td class="memItemLeft" align="right" valign="top"><a id="a6668b0ffe41e701cc44337546d233465"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a6668b0ffe41e701cc44337546d233465">makeBaseW</a> ()</td></tr>
<tr class="memdesc:a6668b0ffe41e701cc44337546d233465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual pre-creator of <em>W</em>. <br /></td></tr>
<tr class="separator:a6668b0ffe41e701cc44337546d233465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af996b71b5762e8284226a96c6aac8d87"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#af996b71b5762e8284226a96c6aac8d87">makeBaseQ</a> ()</td></tr>
<tr class="memdesc:af996b71b5762e8284226a96c6aac8d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual pre-creator of <em>Q</em>.  <a href="#af996b71b5762e8284226a96c6aac8d87">More...</a><br /></td></tr>
<tr class="separator:af996b71b5762e8284226a96c6aac8d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2acc1502881abeb70155762fe3e3a644"><td class="memItemLeft" align="right" valign="top"><a id="a2acc1502881abeb70155762fe3e3a644"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a2acc1502881abeb70155762fe3e3a644">makeBaseH</a> ()</td></tr>
<tr class="memdesc:a2acc1502881abeb70155762fe3e3a644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual pre-creator of <em>H</em>. <br /></td></tr>
<tr class="separator:a2acc1502881abeb70155762fe3e3a644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e6e032ae5db155eb7d1ba1401db9be"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a72e6e032ae5db155eb7d1ba1401db9be">makeBaseV</a> ()</td></tr>
<tr class="memdesc:a72e6e032ae5db155eb7d1ba1401db9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual pre-creator of <em>V</em>.  <a href="#a72e6e032ae5db155eb7d1ba1401db9be">More...</a><br /></td></tr>
<tr class="separator:a72e6e032ae5db155eb7d1ba1401db9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa2b05e931d64bf8f762812e06ce369"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#adaa2b05e931d64bf8f762812e06ce369">makeBaseR</a> ()</td></tr>
<tr class="memdesc:adaa2b05e931d64bf8f762812e06ce369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual pre-creator of <em>R</em>.  <a href="#adaa2b05e931d64bf8f762812e06ce369">More...</a><br /></td></tr>
<tr class="separator:adaa2b05e931d64bf8f762812e06ce369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrix Creators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Theses functions have been designed to be overridden by derived classes if necessary. Their role is to fill in the parts of the Kalman matrices that change between iterations. That is to say, these functions should set values inside matrices that depend on <em>x</em> or <em>u</em>.</p>
<p>These functions can suppose that their corresponding matrix pre-creator has been called at least once before. Also, <code><a class="el" href="classKalman_1_1EKFilter.html#aa2cd9e16f121fe26802a133b4cb37f59" title="Virtual creator of A. ">makeA()</a></code>, <code><a class="el" href="classKalman_1_1EKFilter.html#ac0ea9285a523d219835f7ca2ce932902" title="Virtual creator of W. ">makeW()</a></code>, <code><a class="el" href="classKalman_1_1EKFilter.html#ab9765c4cbe0f67a1aa82ddfbc8173877" title="Virtual creator of Q. ">makeQ()</a></code> and <code><a class="el" href="classKalman_1_1EKFilter.html#a778232d397d981c08b3ca23ea800aa6a" title="Actual process . Fills in new x by using old x. ">makeProcess()</a></code> can suppose that <code><a class="el" href="classKalman_1_1EKFilter.html#aace6f213340e7a0c78541454b13e8586" title="Optional function used to precalculate common values for process. ">makeCommonProcess()</a></code> is called every time just before it being called. Same thing for <code><a class="el" href="classKalman_1_1EKFilter.html#a357df3cc6833241d5430c58feaed14ed" title="Virtual creator of H. ">makeH()</a></code>, <code><a class="el" href="classKalman_1_1EKFilter.html#a70bb019d226cbf9858954b81c89392a7" title="Virtual creator of V. ">makeV()</a></code>, <code><a class="el" href="classKalman_1_1EKFilter.html#aff7a7f2d08673db1330e04e349b3bb8b" title="Virtual creator of R. ">makeR()</a></code> and <code><a class="el" href="classKalman_1_1EKFilter.html#aac9f6d80e5ec9e6ea2ccf045cb682df8" title="Actual measurement function . Fills in z. ">makeMeasure()</a></code> about <code><a class="el" href="classKalman_1_1EKFilter.html#a89337cacd8115338ffd34637f0ecbd92" title="Optional function used to precalculate common values for measurement. ">makeCommonMeasure()</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>Matrices have already been properly resized before these functions are called, so no further resizing is or should be necessary. </dd>
<dd>
If a matrix creator is overridden, but it does not modify in any way the matrix in certain execution paths, then the function <code><a class="el" href="classKalman_1_1EKFilter.html#ae3350773ed390892c2dd6dfe9dfbca89" title="Allows optimizations on some calculations. ">NoModification()</a></code> should be called in each of those execution paths so that the filter can optimize away some calculations. The default versions of the matrix creators only call <code><a class="el" href="classKalman_1_1EKFilter.html#ae3350773ed390892c2dd6dfe9dfbca89" title="Allows optimizations on some calculations. ">NoModification()</a></code> in their bodies. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Each matrix creator cannot suppose that any other matrix creator will be called before or after it. One thing is sure : <code>makeCommon*</code>() is called first, then some of <code>make*</code>() and finally, <code><a class="el" href="classKalman_1_1EKFilter.html#a778232d397d981c08b3ca23ea800aa6a" title="Actual process . Fills in new x by using old x. ">makeProcess()</a></code> or <code><a class="el" href="classKalman_1_1EKFilter.html#aac9f6d80e5ec9e6ea2ccf045cb682df8" title="Actual measurement function . Fills in z. ">makeMeasure()</a></code>. </dd>
<dd>
These functions can access <em>x</em> and <em>u</em> in read-only mode, except <a class="el" href="classKalman_1_1EKFilter.html#a778232d397d981c08b3ca23ea800aa6a" title="Actual process . Fills in new x by using old x. ">makeProcess()</a>, which must modify <em>x</em>. </dd></dl>
</div></td></tr>
<tr class="memitem:aace6f213340e7a0c78541454b13e8586"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#aace6f213340e7a0c78541454b13e8586">makeCommonProcess</a> ()</td></tr>
<tr class="memdesc:aace6f213340e7a0c78541454b13e8586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional function used to precalculate common values for process.  <a href="#aace6f213340e7a0c78541454b13e8586">More...</a><br /></td></tr>
<tr class="separator:aace6f213340e7a0c78541454b13e8586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cd9e16f121fe26802a133b4cb37f59"><td class="memItemLeft" align="right" valign="top"><a id="aa2cd9e16f121fe26802a133b4cb37f59"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#aa2cd9e16f121fe26802a133b4cb37f59">makeA</a> ()</td></tr>
<tr class="memdesc:aa2cd9e16f121fe26802a133b4cb37f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual creator of <em>A</em>. <br /></td></tr>
<tr class="separator:aa2cd9e16f121fe26802a133b4cb37f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ea9285a523d219835f7ca2ce932902"><td class="memItemLeft" align="right" valign="top"><a id="ac0ea9285a523d219835f7ca2ce932902"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#ac0ea9285a523d219835f7ca2ce932902">makeW</a> ()</td></tr>
<tr class="memdesc:ac0ea9285a523d219835f7ca2ce932902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual creator of <em>W</em>. <br /></td></tr>
<tr class="separator:ac0ea9285a523d219835f7ca2ce932902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9765c4cbe0f67a1aa82ddfbc8173877"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#ab9765c4cbe0f67a1aa82ddfbc8173877">makeQ</a> ()</td></tr>
<tr class="memdesc:ab9765c4cbe0f67a1aa82ddfbc8173877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual creator of <em>Q</em>.  <a href="#ab9765c4cbe0f67a1aa82ddfbc8173877">More...</a><br /></td></tr>
<tr class="separator:ab9765c4cbe0f67a1aa82ddfbc8173877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778232d397d981c08b3ca23ea800aa6a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a778232d397d981c08b3ca23ea800aa6a">makeProcess</a> ()=0</td></tr>
<tr class="memdesc:a778232d397d981c08b3ca23ea800aa6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual process <img class="formulaInl" alt="$ f(x, u, 0) $" src="form_51.png"/>. Fills in new <em>x</em> by using old <em>x</em>.  <a href="#a778232d397d981c08b3ca23ea800aa6a">More...</a><br /></td></tr>
<tr class="separator:a778232d397d981c08b3ca23ea800aa6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89337cacd8115338ffd34637f0ecbd92"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a89337cacd8115338ffd34637f0ecbd92">makeCommonMeasure</a> ()</td></tr>
<tr class="memdesc:a89337cacd8115338ffd34637f0ecbd92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional function used to precalculate common values for measurement.  <a href="#a89337cacd8115338ffd34637f0ecbd92">More...</a><br /></td></tr>
<tr class="separator:a89337cacd8115338ffd34637f0ecbd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357df3cc6833241d5430c58feaed14ed"><td class="memItemLeft" align="right" valign="top"><a id="a357df3cc6833241d5430c58feaed14ed"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a357df3cc6833241d5430c58feaed14ed">makeH</a> ()</td></tr>
<tr class="memdesc:a357df3cc6833241d5430c58feaed14ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual creator of <em>H</em>. <br /></td></tr>
<tr class="separator:a357df3cc6833241d5430c58feaed14ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bb019d226cbf9858954b81c89392a7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a70bb019d226cbf9858954b81c89392a7">makeV</a> ()</td></tr>
<tr class="memdesc:a70bb019d226cbf9858954b81c89392a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual creator of <em>V</em>.  <a href="#a70bb019d226cbf9858954b81c89392a7">More...</a><br /></td></tr>
<tr class="separator:a70bb019d226cbf9858954b81c89392a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7a7f2d08673db1330e04e349b3bb8b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#aff7a7f2d08673db1330e04e349b3bb8b">makeR</a> ()</td></tr>
<tr class="memdesc:aff7a7f2d08673db1330e04e349b3bb8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual creator of <em>R</em>.  <a href="#aff7a7f2d08673db1330e04e349b3bb8b">More...</a><br /></td></tr>
<tr class="separator:aff7a7f2d08673db1330e04e349b3bb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9f6d80e5ec9e6ea2ccf045cb682df8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#aac9f6d80e5ec9e6ea2ccf045cb682df8">makeMeasure</a> ()=0</td></tr>
<tr class="memdesc:aac9f6d80e5ec9e6ea2ccf045cb682df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual measurement function <img class="formulaInl" alt="$ h(x, 0) $" src="form_52.png"/>. Fills in <em>z</em>.  <a href="#aac9f6d80e5ec9e6ea2ccf045cb682df8">More...</a><br /></td></tr>
<tr class="separator:aac9f6d80e5ec9e6ea2ccf045cb682df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a168299879f6b3023b0a42b1afe29d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a54a168299879f6b3023b0a42b1afe29d">makeDZ</a> ()</td></tr>
<tr class="memdesc:a54a168299879f6b3023b0a42b1afe29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook-up function to modify innovation vector.  <a href="#a54a168299879f6b3023b0a42b1afe29d">More...</a><br /></td></tr>
<tr class="separator:a54a168299879f6b3023b0a42b1afe29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Kalman Vectors and Matrices</div></td></tr>
<tr class="memitem:abc9456e14fd29b7c82ad901ab3e4e63f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classKalman_1_1EKFilter.html#af773d1217ecb01925b857d49b32bc636">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#abc9456e14fd29b7c82ad901ab3e4e63f">x</a></td></tr>
<tr class="memdesc:abc9456e14fd29b7c82ad901ab3e4e63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Corrected state vector.  <a href="#abc9456e14fd29b7c82ad901ab3e4e63f">More...</a><br /></td></tr>
<tr class="separator:abc9456e14fd29b7c82ad901ab3e4e63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4403db2f52f9a47cd9f432fc44e0a5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classKalman_1_1EKFilter.html#af773d1217ecb01925b857d49b32bc636">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#ad4403db2f52f9a47cd9f432fc44e0a5d">u</a></td></tr>
<tr class="memdesc:ad4403db2f52f9a47cd9f432fc44e0a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input vector.  <a href="#ad4403db2f52f9a47cd9f432fc44e0a5d">More...</a><br /></td></tr>
<tr class="separator:ad4403db2f52f9a47cd9f432fc44e0a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91baacb49f7fae74c449c1d21424f126"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classKalman_1_1EKFilter.html#af773d1217ecb01925b857d49b32bc636">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a91baacb49f7fae74c449c1d21424f126">z</a></td></tr>
<tr class="memdesc:a91baacb49f7fae74c449c1d21424f126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicted measurement vector.  <a href="#a91baacb49f7fae74c449c1d21424f126">More...</a><br /></td></tr>
<tr class="separator:a91baacb49f7fae74c449c1d21424f126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1976aeb370c1741133bf47528ff8e03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classKalman_1_1EKFilter.html#af773d1217ecb01925b857d49b32bc636">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#af1976aeb370c1741133bf47528ff8e03">dz</a></td></tr>
<tr class="memdesc:af1976aeb370c1741133bf47528ff8e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Innovation vector.  <a href="#af1976aeb370c1741133bf47528ff8e03">More...</a><br /></td></tr>
<tr class="separator:af1976aeb370c1741133bf47528ff8e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d936cd96a598b5d8534aeb474012c5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classKalman_1_1EKFilter.html#a7cbc4cb4d9139a7f241b27110426af43">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a5d936cd96a598b5d8534aeb474012c5a">A</a></td></tr>
<tr class="memdesc:a5d936cd96a598b5d8534aeb474012c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A jacobian matrix.  <a href="#a5d936cd96a598b5d8534aeb474012c5a">More...</a><br /></td></tr>
<tr class="separator:a5d936cd96a598b5d8534aeb474012c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a50c13fef614d595d01afa70184db84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classKalman_1_1EKFilter.html#a7cbc4cb4d9139a7f241b27110426af43">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a3a50c13fef614d595d01afa70184db84">W</a></td></tr>
<tr class="memdesc:a3a50c13fef614d595d01afa70184db84"><td class="mdescLeft">&#160;</td><td class="mdescRight">A jacobian matrix.  <a href="#a3a50c13fef614d595d01afa70184db84">More...</a><br /></td></tr>
<tr class="separator:a3a50c13fef614d595d01afa70184db84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f25e9c8bce9efb50cf3c3a5f3ba6822"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classKalman_1_1EKFilter.html#a7cbc4cb4d9139a7f241b27110426af43">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a1f25e9c8bce9efb50cf3c3a5f3ba6822">Q</a></td></tr>
<tr class="memdesc:a1f25e9c8bce9efb50cf3c3a5f3ba6822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process noise covariance matrix.  <a href="#a1f25e9c8bce9efb50cf3c3a5f3ba6822">More...</a><br /></td></tr>
<tr class="separator:a1f25e9c8bce9efb50cf3c3a5f3ba6822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac10c3f39cdcb10bf3bcf30f48efdb48d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classKalman_1_1EKFilter.html#a7cbc4cb4d9139a7f241b27110426af43">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#ac10c3f39cdcb10bf3bcf30f48efdb48d">H</a></td></tr>
<tr class="memdesc:ac10c3f39cdcb10bf3bcf30f48efdb48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A jacobian matrix.  <a href="#ac10c3f39cdcb10bf3bcf30f48efdb48d">More...</a><br /></td></tr>
<tr class="separator:ac10c3f39cdcb10bf3bcf30f48efdb48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9289999f22782549b25b67c4ae81b1c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classKalman_1_1EKFilter.html#a7cbc4cb4d9139a7f241b27110426af43">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a9289999f22782549b25b67c4ae81b1c5">V</a></td></tr>
<tr class="memdesc:a9289999f22782549b25b67c4ae81b1c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A jacobian matrix.  <a href="#a9289999f22782549b25b67c4ae81b1c5">More...</a><br /></td></tr>
<tr class="separator:a9289999f22782549b25b67c4ae81b1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae869345d1d3bb288d87b849556cf7c4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classKalman_1_1EKFilter.html#a7cbc4cb4d9139a7f241b27110426af43">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#ae869345d1d3bb288d87b849556cf7c4f">R</a></td></tr>
<tr class="memdesc:ae869345d1d3bb288d87b849556cf7c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measurement noise covariance matrix.  <a href="#ae869345d1d3bb288d87b849556cf7c4f">More...</a><br /></td></tr>
<tr class="separator:ae869345d1d3bb288d87b849556cf7c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Kalman Dimensions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section warning"><dt>Warning</dt><dd>These values, which are accessible to derived classes, are read-only. The derived classes should use the resizing functions to modify vector and matrix dimensions. </dd></dl>
</div></td></tr>
<tr class="memitem:a6bfb25c8cd793856593b25054cbc3da8"><td class="memItemLeft" align="right" valign="top"><a id="a6bfb25c8cd793856593b25054cbc3da8"></a>
<a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a6bfb25c8cd793856593b25054cbc3da8">n</a></td></tr>
<tr class="memdesc:a6bfb25c8cd793856593b25054cbc3da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the state vector. <br /></td></tr>
<tr class="separator:a6bfb25c8cd793856593b25054cbc3da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b71009af5616611d8dd775084e2237"><td class="memItemLeft" align="right" valign="top"><a id="ac1b71009af5616611d8dd775084e2237"></a>
<a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#ac1b71009af5616611d8dd775084e2237">nu</a></td></tr>
<tr class="memdesc:ac1b71009af5616611d8dd775084e2237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the input vector. <br /></td></tr>
<tr class="separator:ac1b71009af5616611d8dd775084e2237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c465859315350239341b7242c721f9"><td class="memItemLeft" align="right" valign="top"><a id="a93c465859315350239341b7242c721f9"></a>
<a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#a93c465859315350239341b7242c721f9">nw</a></td></tr>
<tr class="memdesc:a93c465859315350239341b7242c721f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the process noise vector. <br /></td></tr>
<tr class="separator:a93c465859315350239341b7242c721f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8dc375c7bed34028a45b17514c88fc"><td class="memItemLeft" align="right" valign="top"><a id="afa8dc375c7bed34028a45b17514c88fc"></a>
<a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#afa8dc375c7bed34028a45b17514c88fc">m</a></td></tr>
<tr class="memdesc:afa8dc375c7bed34028a45b17514c88fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the measurement vector. <br /></td></tr>
<tr class="separator:afa8dc375c7bed34028a45b17514c88fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab839a4708545eac86f62c65be060688e"><td class="memItemLeft" align="right" valign="top"><a id="ab839a4708545eac86f62c65be060688e"></a>
<a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKalman_1_1EKFilter.html#ab839a4708545eac86f62c65be060688e">nv</a></td></tr>
<tr class="memdesc:ab839a4708545eac86f62c65be060688e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the measurement noise vector. <br /></td></tr>
<tr class="separator:ab839a4708545eac86f62c65be060688e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt;<br />
class Kalman::EKFilter&lt; T, BEG, OQ, OVR, DBG &gt;</h3>

<p>Generic Extended Kalman Filter (EKF) template base class. </p>
<dl class="section user"><dt>Usage</dt><dd>"The Kalman filter is a set of mathematical equations that provides an efficient computational (recursive) solution of the least-squares method. The filter is very powerful in several aspects: it supports estimations of past, present, and even future states, and it can do so even when the precise nature of the modeled system is unknown." (quoted from [02]) <br />
 This version of the Kalman filter is in fact a Variable-Dimension Extended Kalman Filter (VDEKF). It supports optimized algorithms (translated from Fortran - see [01]), even in the presence of correlated process or measurement noise. <br />
 To use this template class, you must first inherit from it and implement some virtual functions. See the example page for more informations. Note that you can copy freely an <code>EKFilter-derived</code> class freely : this can be useful if you need to branch your filter based on some condition.</dd></dl>
<dl class="section user"><dt>Notation</dt><dd>We prefered the notation of [02] : here it is. Assume a state vector <img class="formulaInl" alt="$ x $" src="form_37.png"/> (to estimate) and a non-linear process function <img class="formulaInl" alt="$ f $" src="form_2.png"/> (to model) that describes the evolution of this state through time, that is : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_k = f \left( x_{k-1}, u_{k-1}, w_{k-1} \right) \]" src="form_38.png"/>
</p>
 where <img class="formulaInl" alt="$ u $" src="form_14.png"/> is the (known) input vector fed to the process and <img class="formulaInl" alt="$ w $" src="form_4.png"/> is the (unknown) process noise vector due to uncertainty and process modeling errors. Further suppose that the (known) process noise covariance matrix is : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ Q = E \left( w w^T \right) \]" src="form_39.png"/>
</p>
 Now, let's assume a (known) measurement vector <img class="formulaInl" alt="$ z $" src="form_40.png"/>, which depends on the current state <img class="formulaInl" alt="$ x $" src="form_37.png"/> in the form of a non-linear function <img class="formulaInl" alt="$ h $" src="form_36.png"/> (to model) : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ z_k = h \left( x_k, v_k \right) \]" src="form_41.png"/>
</p>
 where <img class="formulaInl" alt="$ v $" src="form_7.png"/> is the (unknown) measurement noise vector with a (known) covariance matrix : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ R = E \left( v v^T \right) \]" src="form_42.png"/>
</p>
 Suppose that we have an estimate of the previous state <img class="formulaInl" alt="$ \hat{x}_{k-1} $" src="form_43.png"/>, called a corrected state or an <em>a posteriori</em> state estimate. We can build a predicted state (also called an <em>a priori</em> state estimate) by using <img class="formulaInl" alt="$ f $" src="form_2.png"/> : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tilde{x}_k = f \left( \hat{x}_{k-1}, u_{k-1}, 0 \right) \]" src="form_44.png"/>
</p>
 since the input is known and the process noise, unknown. With this predicted state, we can get a predicted measurement vector by using <img class="formulaInl" alt="$ h $" src="form_36.png"/> : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tilde{z}_k = h \left( \tilde{x}_k, 0 \right) \]" src="form_45.png"/>
</p>
 since the measurement noise is unknown. To obtain a linear least-squares formulation, we need to linearize those two systems. Here are first-order Taylor series centered on <img class="formulaInl" alt="$ \tilde{x}_k $" src="form_46.png"/>: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_k \approx f \left( \hat{x}_{k-1}, u_{k-1}, 0 \right) //! + \frac{\partial f}{\partial x} \left( \hat{x}_{k-1}, u_{k-1}, 0 \right) //! \left( \Delta x \right) //! + \frac{\partial f}{\partial u} \left( \hat{x}_{k-1}, u_{k-1}, 0 \right) //! \left( \Delta u \right) //! + \frac{\partial f}{\partial w} \left( \hat{x}_{k-1}, u_{k-1}, 0 \right) //! \left( \Delta w \right) \]" src="form_47.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \phantom{x_k} = \tilde{x}_k + A \left( x_{k-1} - \hat{x}_{k-1} //! \right) + W w_{k-1} \]" src="form_48.png"/>
</p>
 We can do the same for the other system : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ z_k \approx h \left( \tilde{x}_k, 0 \right) //! + \frac{\partial h}{\partial x} \left( \tilde{x}_k, 0 \right) //! \left( \Delta x \right) //! + \frac{\partial h}{\partial v} \left( \tilde{x}_k, 0 \right) //! \left( \Delta v \right) \]" src="form_49.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \phantom{z_k} = \tilde{z}_k + H \left( x_k - \tilde{x}_k \right) //! + V v_k \]" src="form_50.png"/>
</p>
 The user of this class must derive from it, and implement all the functions corresponding to <em>A</em>, <em>W</em>, <em>Q</em>, f, <em>H</em>, <em>V</em>, <em>R</em> and h.</dd></dl>
<dl class="section user"><dt>References</dt><dd>[01] Bierman, G. J. "Factorization Methods for Discrete Sequential
    Estimation", Academic Press, 1977. <br />
 [02] Welch, G. and Bishop, G. "An Introduction to the %Kalman Filter", <a href="http://www.cs.unc.edu/~welch/kalman/kalmanIntro.html">http://www.cs.unc.edu/~welch/kalman/kalmanIntro.html</a></dd></dl>
<dl class="section user"><dt>Template parameters</dt><dd><ul>
<li><code>T</code> : Type of elements contained in matrices and vectors. Usually <code>float</code> or <code>double</code>.</li>
<li><code>BEG</code> : Starting index of matrices and vectors. Can be either 0 or 1.</li>
<li><code>OQ</code> : Optimize calculations on <em>Q</em>. This can be turned on if <em>Q</em> is diagonal.</li>
<li><code>OVR</code> : Optimize calculations on <em>V</em> and <em>R</em>. This can be turned on if <em>V</em> and <em>R</em> are both diagonal matrices.</li>
<li><code>DGB</code> : Debug flag. If <code>true</code>, then bound-checking will be performed, and <code><a class="el" href="structKalman_1_1OutOfBoundError.html" title="Exception class for access to out-of-bound elements. ">OutOfBoundError</a></code> exceptions can be thrown.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Type requirements for T</dt><dd><ul>
<li><code>T</code> must be <b>default constructible</b>.</li>
<li><code>T</code> must be <b>constructible from</b> <code>double</code>.</li>
<li><code>T</code> must be <b>assignable</b>.</li>
<li><code>T</code> must be <b>equality comparable</b>.</li>
<li><code>T</code> must be <b>serializable</b>.</li>
<li><code>T</code> must support <b>basic arithmetic operations</b>.</li>
</ul>
This means that, if <code>t1</code>, <code>t2</code> are instances of <code>T</code>, <code>op</code> is an arithmetic operator (+ - * /), <code>is</code> is of type <code>istream</code> and <code>os</code> is of type <code>ostream</code>, the following expressions must be valid :<ul>
<li><div class="fragment"><div class="line">T(); T t1; </div></div><!-- fragment --> Default constructor</li>
<li><div class="fragment"><div class="line">T(0.0); T t1(1.0); </div></div><!-- fragment --> Constructor from <code>double</code> </li>
<li><div class="fragment"><div class="line">T t1 = t2; T t1(t2); T(t1); </div></div><!-- fragment --> Copy constructor</li>
<li><div class="fragment"><div class="line">t1 op t2 </div></div><!-- fragment --> Arithmetic operation, convertible to <code>T</code> </li>
<li><div class="fragment"><div class="line">-t1 </div></div><!-- fragment --> Negation operator, convertible to <code>T</code>. Same as :<div class="fragment"><div class="line">T(0.0) - t1; </div></div><!-- fragment --></li>
<li><div class="fragment"><div class="line">t1 = t2; </div></div><!-- fragment --> Assignment operator</li>
<li><div class="fragment"><div class="line">t1 op= t2; </div></div><!-- fragment --> Arithmetic inplace operation. Same as :<div class="fragment"><div class="line">t1 = t1 op t2; </div></div><!-- fragment --></li>
<li><div class="fragment"><div class="line">t1 == t2 </div></div><!-- fragment --> Equality comparison, convertible to <code>bool</code> </li>
<li><div class="fragment"><div class="line">is &gt;&gt; t1; </div></div><!-- fragment --> <code><a class="el" href="namespaceKalman.html#a72ce00e837fa126ab3961f879e3d8b87" title="Reads a matrix from a stream. ">operator&gt;&gt;()</a></code> </li>
<li><div class="fragment"><div class="line">os &lt;&lt; t1; </div></div><!-- fragment --> <code><a class="el" href="namespaceKalman.html#a531684dadbec9b34313492f6d5121598" title="Writes a matrix to a stream. ">operator&lt;&lt;()</a></code> </li>
</ul>
</dd></dl>
<p>Finally, note that <code><a class="el" href="namespaceKalman.html#a72ce00e837fa126ab3961f879e3d8b87" title="Reads a matrix from a stream. ">operator&gt;&gt;()</a></code> and <code><a class="el" href="namespaceKalman.html#a531684dadbec9b34313492f6d5121598" title="Writes a matrix to a stream. ">operator&lt;&lt;()</a></code> must be compatible. Also, <code>operator&amp;()</code> must not have been overloaded. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a0665fa7fa760b5235cb556e2503ff687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0665fa7fa760b5235cb556e2503ff687">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0665fa7fa760b5235cb556e2503ff687aa3adf9ec22ed3a246105276c85a146c1"></a>beg&#160;</td><td class="fielddoc"><p>Starting index of matrices and vectors. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaf0ddc0f02fe2064481400de28a27fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0ddc0f02fe2064481400de28a27fde">&#9670;&nbsp;</a></span>EKFilter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="classKalman_1_1EKFilter.html">EKFilter</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a>&#160;</td>
          <td class="paramname"><em>n_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a>&#160;</td>
          <td class="paramname"><em>nu_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a>&#160;</td>
          <td class="paramname"><em>nw_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a>&#160;</td>
          <td class="paramname"><em>m_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a>&#160;</td>
          <td class="paramname"><em>nv_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructors specifying all necessary matrix and vector dimensions. </p>
<p>This constructor simply calls <code><a class="el" href="classKalman_1_1EKFilter.html#a0c311fd7fc6d57c206029ea0e902cf2e" title="Sets all dimensions at once. ">setDim()</a></code> with all the corresponding arguments. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af73c892e9624013167ddecc04be01044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73c892e9624013167ddecc04be01044">&#9670;&nbsp;</a></span>calculateP()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const KTYPENAME <a class="el" href="classKalman_1_1EKFilter.html">EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="classKalman_1_1EKFilter.html#a7cbc4cb4d9139a7f241b27110426af43">Matrix</a> &amp; <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::calculateP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <em>a posteriori</em> error covariance estimate matrix. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is not a simple return statement. Since P is not kept and updated in the filter (an alternate and more stable representation of P is used), calculations are involved to retrieve P. So, use this function wisely. </dd>
<dd>
For better efficiency, P is returned by reference. The reference points to an internal member of the filter, which means that other functions may invalidate the contents of this matrix. This also means that this matrix must be copied (or better yet, swapped) as soon as possible if its data is needed later. </dd></dl>

</div>
</div>
<a id="a80d5dc8f46e8f5d4ec3a6b1e804fdc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d5dc8f46e8f5d4ec3a6b1e804fdc9f">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classKalman_1_1EKFilter.html#af773d1217ecb01925b857d49b32bc636">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>x_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKalman_1_1EKFilter.html#a7cbc4cb4d9139a7f241b27110426af43">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>P_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets initial conditions for the Kalman Filter. </p>
<p>This function allows to set an initial state estimate vector and an initial error covariance matrix estimate. This must be called at least once, after all dimensioning functions and before any other function. However, it can also be called anytime to reset or modify <em>x</em> or <em>P</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x_</td><td>State vector estimate. Will be destroyed. </td></tr>
    <tr><td class="paramname">P_</td><td>Error covariance matrix estimate. Will be destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If <code><a class="el" href="classKalman_1_1EKFilter.html#a0c311fd7fc6d57c206029ea0e902cf2e" title="Sets all dimensions at once. ">setDim()</a></code>, <code><a class="el" href="classKalman_1_1EKFilter.html#a9c56983458ab0d3dca1a855baee71280" title="Sets the size of the state vector. ">setSizeX()</a></code> or <code><a class="el" href="classKalman_1_1EKFilter.html#a6518bb07784ffd30edc70750ec0459f1" title="Sets the size of the process noise vector. ">setSizeW()</a></code> is called, then <a class="el" href="classKalman_1_1EKFilter.html#a80d5dc8f46e8f5d4ec3a6b1e804fdc9f" title="Sets initial conditions for the Kalman Filter. ">init()</a> must be called again before any other non-dimensioning function. </dd></dl>

</div>
</div>
<a id="af996b71b5762e8284226a96c6aac8d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af996b71b5762e8284226a96c6aac8d87">&#9670;&nbsp;</a></span>makeBaseQ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeBaseQ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual pre-creator of <em>Q</em>. </p>
<dl class="section note"><dt>Note</dt><dd>If <code>OQ</code> is <code>true</code>, that is, if <code>Q</code> is always diagonal, then it is not necessary to initialize non-diagonal elements with anything meaningful. </dd></dl>

</div>
</div>
<a id="adaa2b05e931d64bf8f762812e06ce369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa2b05e931d64bf8f762812e06ce369">&#9670;&nbsp;</a></span>makeBaseR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeBaseR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual pre-creator of <em>R</em>. </p>
<dl class="section note"><dt>Note</dt><dd>If <code>OVR</code> is <code>true</code>, that is, if <code>both</code> V and R are always diagonal, then it is not necessary to initialize non-diagonal elements with anything meaningful. </dd></dl>

</div>
</div>
<a id="a72e6e032ae5db155eb7d1ba1401db9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e6e032ae5db155eb7d1ba1401db9be">&#9670;&nbsp;</a></span>makeBaseV()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeBaseV </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual pre-creator of <em>V</em>. </p>
<dl class="section note"><dt>Note</dt><dd>If <code>OVR</code> is <code>true</code>, that is, if <code>both</code> V and R are always diagonal, then it is not necessary to initialize non-diagonal elements with anything meaningful. </dd></dl>

</div>
</div>
<a id="a89337cacd8115338ffd34637f0ecbd92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89337cacd8115338ffd34637f0ecbd92">&#9670;&nbsp;</a></span>makeCommonMeasure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeCommonMeasure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optional function used to precalculate common values for measurement. </p>
<p>If complex calculations are needed for more than one of <code><a class="el" href="classKalman_1_1EKFilter.html#a357df3cc6833241d5430c58feaed14ed" title="Virtual creator of H. ">makeH()</a></code>, <code><a class="el" href="classKalman_1_1EKFilter.html#a70bb019d226cbf9858954b81c89392a7" title="Virtual creator of V. ">makeV()</a></code>, <code><a class="el" href="classKalman_1_1EKFilter.html#aff7a7f2d08673db1330e04e349b3bb8b" title="Virtual creator of R. ">makeR()</a></code>, <code><a class="el" href="classKalman_1_1EKFilter.html#aac9f6d80e5ec9e6ea2ccf045cb682df8" title="Actual measurement function . Fills in z. ">makeMeasure()</a></code> and <code><a class="el" href="classKalman_1_1EKFilter.html#a54a168299879f6b3023b0a42b1afe29d" title="Hook-up function to modify innovation vector. ">makeDZ()</a></code> functions, then this function can be used to store the results in temporary variables of the derived class. </p><dl class="section warning"><dt>Warning</dt><dd>This function must not modify any matrix of the base class. </dd>
<dd>
This function must not be used to store permanent state. In other words, all calculations performed in this function should be temporary. This is because the <code><a class="el" href="classKalman_1_1EKFilter.html#ae111e647e38f64bed354c85ff8f5c3ad" title="Returns the predicted measurement vector. ">simulate()</a></code> function will call this function but has no knowledge of how to undo it. </dd></dl>

</div>
</div>
<a id="aace6f213340e7a0c78541454b13e8586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace6f213340e7a0c78541454b13e8586">&#9670;&nbsp;</a></span>makeCommonProcess()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeCommonProcess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optional function used to precalculate common values for process. </p>
<p>If complex calculations are needed for more than one of <code><a class="el" href="classKalman_1_1EKFilter.html#aa2cd9e16f121fe26802a133b4cb37f59" title="Virtual creator of A. ">makeA()</a></code>, <code><a class="el" href="classKalman_1_1EKFilter.html#ac0ea9285a523d219835f7ca2ce932902" title="Virtual creator of W. ">makeW()</a></code>, <code><a class="el" href="classKalman_1_1EKFilter.html#ab9765c4cbe0f67a1aa82ddfbc8173877" title="Virtual creator of Q. ">makeQ()</a></code> and <code><a class="el" href="classKalman_1_1EKFilter.html#a778232d397d981c08b3ca23ea800aa6a" title="Actual process . Fills in new x by using old x. ">makeProcess()</a></code> functions, then this function can be used to store the results in temporary variables of the derived class. </p><dl class="section warning"><dt>Warning</dt><dd>This function must not modify any matrix of the base class. </dd>
<dd>
This function must not be used to store permanent state. In other words, all calculations performed in this function should be temporary. This is because the <code><a class="el" href="classKalman_1_1EKFilter.html#a5f50329514f21971663ae6d4a26a1bb6" title="Returns the predicted state vector (a priori state estimate). ">predict()</a></code> function will call this function but has no knowledge of how to undo it. </dd></dl>

</div>
</div>
<a id="a54a168299879f6b3023b0a42b1afe29d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54a168299879f6b3023b0a42b1afe29d">&#9670;&nbsp;</a></span>makeDZ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeDZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hook-up function to modify innovation vector. </p>
<p>This function should rarely be overridden ; this is more of a hack than anything else. In fact, this is used to perform adjustements on the result of substracting the predicted measurement vector to the real measurement vector. This is needed, for example, when measures include angles. It may be mandatory that the difference of the two angles be in a certain range, like <img class="formulaInl" alt="$ [-\pi, \pi] $" src="form_53.png"/>. </p>

</div>
</div>
<a id="aac9f6d80e5ec9e6ea2ccf045cb682df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac9f6d80e5ec9e6ea2ccf045cb682df8">&#9670;&nbsp;</a></span>makeMeasure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeMeasure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Actual measurement function <img class="formulaInl" alt="$ h(x, 0) $" src="form_52.png"/>. Fills in <em>z</em>. </p>
<p>This function <b>must</b> be overridden, since it is the core of the measurement system. At the time this will be called, <em>x</em> contains the predicted state (<em>a priori</em> state estimate), which is the one that must be used with the measurement function. </p><dl class="section warning"><dt>Warning</dt><dd>This function should have no side effects to class members (even members of derived classes) other than <em>z</em>. This is because this function is used by <code><a class="el" href="classKalman_1_1EKFilter.html#ae111e647e38f64bed354c85ff8f5c3ad" title="Returns the predicted measurement vector. ">simulate()</a></code>, which does a calculation and then undoes it before returning the result. </dd></dl>

</div>
</div>
<a id="a778232d397d981c08b3ca23ea800aa6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778232d397d981c08b3ca23ea800aa6a">&#9670;&nbsp;</a></span>makeProcess()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeProcess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Actual process <img class="formulaInl" alt="$ f(x, u, 0) $" src="form_51.png"/>. Fills in new <em>x</em> by using old <em>x</em>. </p>
<p>This function <b>must</b> be overridden, since it is the core of the system process. </p><dl class="section warning"><dt>Warning</dt><dd>This function should have no side effects to class members (even members of derived classes) other than <em>x</em>. This is because this function is used by <code><a class="el" href="classKalman_1_1EKFilter.html#a5f50329514f21971663ae6d4a26a1bb6" title="Returns the predicted state vector (a priori state estimate). ">predict()</a></code>, which does a calculation and then undoes it before returning the result. </dd></dl>

</div>
</div>
<a id="ab9765c4cbe0f67a1aa82ddfbc8173877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9765c4cbe0f67a1aa82ddfbc8173877">&#9670;&nbsp;</a></span>makeQ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeQ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual creator of <em>Q</em>. </p>
<dl class="section note"><dt>Note</dt><dd>If <code>OQ</code> is <code>true</code>, that is, if <code>Q</code> is always diagonal, then it is not necessary to initialize non-diagonal elements with anything meaningful. </dd></dl>

</div>
</div>
<a id="aff7a7f2d08673db1330e04e349b3bb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff7a7f2d08673db1330e04e349b3bb8b">&#9670;&nbsp;</a></span>makeR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual creator of <em>R</em>. </p>
<dl class="section note"><dt>Note</dt><dd>If <code>OVR</code> is <code>true</code>, that is, if <code>both</code> V and R are always diagonal, then it is not necessary to initialize non-diagonal elements with anything meaningful. </dd></dl>

</div>
</div>
<a id="a70bb019d226cbf9858954b81c89392a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70bb019d226cbf9858954b81c89392a7">&#9670;&nbsp;</a></span>makeV()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeV </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual creator of <em>V</em>. </p>
<dl class="section note"><dt>Note</dt><dd>If <code>OVR</code> is <code>true</code>, that is, if <code>both</code> V and R are always diagonal, then it is not necessary to initialize non-diagonal elements with anything meaningful. </dd></dl>

</div>
</div>
<a id="a01c2889b2229cb815f9e4b10b0402110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c2889b2229cb815f9e4b10b0402110">&#9670;&nbsp;</a></span>measureUpdateStep()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::measureUpdateStep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classKalman_1_1EKFilter.html#af773d1217ecb01925b857d49b32bc636">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>z_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes one correction step. </p>
<p>First, this function resizes any matrix who needs it. If <code>z_</code> is empty, that is, if there are no measures in this step, there is no correction and the function stops there. Else, the measure update phase begins. This means that the following virtual functions <em>should be</em> called : <code><a class="el" href="classKalman_1_1EKFilter.html#a89337cacd8115338ffd34637f0ecbd92" title="Optional function used to precalculate common values for measurement. ">makeCommonMeasure()</a></code>, <code>makeHImpl()</code>, <code>makeVImpl()</code>, <code>makeRImpl()</code>, <code><a class="el" href="classKalman_1_1EKFilter.html#aac9f6d80e5ec9e6ea2ccf045cb682df8" title="Actual measurement function . Fills in z. ">makeMeasure()</a></code> and <code><a class="el" href="classKalman_1_1EKFilter.html#a54a168299879f6b3023b0a42b1afe29d" title="Hook-up function to modify innovation vector. ">makeDZ()</a></code>.After this phase, <em>x</em> contains the new corrected state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z_</td><td>Measurement vector. Will <b>not</b> be destroyed. Can be empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3350773ed390892c2dd6dfe9dfbca89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3350773ed390892c2dd6dfe9dfbca89">&#9670;&nbsp;</a></span>NoModification()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::NoModification </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows optimizations on some calculations. </p>
<p>By default, the <a class="el" href="classKalman_1_1EKFilter.html" title="Generic Extended Kalman Filter (EKF) template base class. ">EKFilter</a> template class suppose that matrix pre-creators and creators modify all matrices. However, if it could suppose that some of these functions do not modify anything, some calculations could be optimized away. The <code><a class="el" href="classKalman_1_1EKFilter.html#ae3350773ed390892c2dd6dfe9dfbca89" title="Allows optimizations on some calculations. ">NoModification()</a></code> function says that the function in which it has been called has not modified any matrix. For optimization purposes, this means that this function should be called in every non-mutating execution branch of all <code>make*</code>() and <code>makeBase*</code>() functions. </p>

</div>
</div>
<a id="a5f50329514f21971663ae6d4a26a1bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f50329514f21971663ae6d4a26a1bb6">&#9670;&nbsp;</a></span>predict()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const KTYPENAME <a class="el" href="classKalman_1_1EKFilter.html">EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="classKalman_1_1EKFilter.html#af773d1217ecb01925b857d49b32bc636">Vector</a> &amp; <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::predict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classKalman_1_1EKFilter.html#af773d1217ecb01925b857d49b32bc636">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>u_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the predicted state vector (<em>a priori</em> state estimate). </p>
<p>This function is used to predict a future state. First, it resizes any matrix who needs it. Then, it does a partial time update, in the sense that only <em>x</em> is updated, not P. This also means that only the following virtual functions <em>should be</em> called : <code><a class="el" href="classKalman_1_1EKFilter.html#aace6f213340e7a0c78541454b13e8586" title="Optional function used to precalculate common values for process. ">makeCommonProcess()</a></code> and <code><a class="el" href="classKalman_1_1EKFilter.html#a778232d397d981c08b3ca23ea800aa6a" title="Actual process . Fills in new x by using old x. ">makeProcess()</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u_</td><td>Input vector. Will <b>not</b> be destroyed. Can be empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The real <em>x</em> is not modified by this function (this is a <code>const</code> function). Only a copy of <em>x</em> is returned. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>For better efficiency, the prediction is returned by reference. The reference points to an internal member of the filter, which means that a new prediction (and many other functions) will invalidate the contents of this vector. This also means that this vector must be copied (or better yet, swapped) as soon as possible if its data is needed later. </dd></dl>

</div>
</div>
<a id="a0c311fd7fc6d57c206029ea0e902cf2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c311fd7fc6d57c206029ea0e902cf2e">&#9670;&nbsp;</a></span>setDim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::setDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a>&#160;</td>
          <td class="paramname"><em>n_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a>&#160;</td>
          <td class="paramname"><em>nu_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a>&#160;</td>
          <td class="paramname"><em>nw_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a>&#160;</td>
          <td class="paramname"><em>m_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a>&#160;</td>
          <td class="paramname"><em>nv_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all dimensions at once. </p>
<p>This function simply calls the <code>setSize*</code>() functions for <code>x, u, w, z, v</code> with the corresponding arguments. </p><dl class="section warning"><dt>Warning</dt><dd>This function (or the corresponding five <code>setSize*</code>() functions) must be called before any other functions. </dd>
<dd>
<code><a class="el" href="classKalman_1_1EKFilter.html#a80d5dc8f46e8f5d4ec3a6b1e804fdc9f" title="Sets initial conditions for the Kalman Filter. ">init()</a></code> must always be called after this function and before any other non-dimensioning function. </dd></dl>

</div>
</div>
<a id="a6518bb07784ffd30edc70750ec0459f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6518bb07784ffd30edc70750ec0459f1">&#9670;&nbsp;</a></span>setSizeW()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::setSizeW </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a>&#160;</td>
          <td class="paramname"><em>nw_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the size of the process noise vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nw_</td><td>New process noise vector size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd><code><a class="el" href="classKalman_1_1EKFilter.html#a80d5dc8f46e8f5d4ec3a6b1e804fdc9f" title="Sets initial conditions for the Kalman Filter. ">init()</a></code> must always be called after this function and before any other non-dimensioning function. </dd></dl>

</div>
</div>
<a id="a9c56983458ab0d3dca1a855baee71280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c56983458ab0d3dca1a855baee71280">&#9670;&nbsp;</a></span>setSizeX()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::setSizeX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceKalman.html#a628a50cae10f6e2035393d4f96c698bd">K_UINT_32</a>&#160;</td>
          <td class="paramname"><em>n_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the size of the state vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_</td><td>New state vector size. Must not be 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd><code><a class="el" href="classKalman_1_1EKFilter.html#a80d5dc8f46e8f5d4ec3a6b1e804fdc9f" title="Sets initial conditions for the Kalman Filter. ">init()</a></code> must always be called after this function and before any other non-dimensioning function. </dd></dl>

</div>
</div>
<a id="ae111e647e38f64bed354c85ff8f5c3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae111e647e38f64bed354c85ff8f5c3ad">&#9670;&nbsp;</a></span>simulate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const KTYPENAME <a class="el" href="classKalman_1_1EKFilter.html">EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="classKalman_1_1EKFilter.html#af773d1217ecb01925b857d49b32bc636">Vector</a> &amp; <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::simulate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the predicted measurement vector. </p>
<p>This function is used to predict a future measurement. First, it resizes any matrix who needs it. Then, it does a partial measure update, in the sense that only <em>z</em> is calculated : <em>x</em> and P are not updated. This also means that only the following virtual functions <em>should be</em> called : <code><a class="el" href="classKalman_1_1EKFilter.html#a89337cacd8115338ffd34637f0ecbd92" title="Optional function used to precalculate common values for measurement. ">makeCommonMeasure()</a></code> and <code><a class="el" href="classKalman_1_1EKFilter.html#aac9f6d80e5ec9e6ea2ccf045cb682df8" title="Actual measurement function . Fills in z. ">makeMeasure()</a></code>. </p><dl class="section note"><dt>Note</dt><dd>This is a <code>const</code> function. It only works on copies of vectors. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>For better efficiency, the prediction is returned by reference. The reference points to an internal member of the filter, which means that a new prediction (and many other functions) will invalidate the contents of this vector. This also means that this vector must be copied (or better yet, swapped) as soon as possible if its data is needed later. </dd></dl>

</div>
</div>
<a id="ac481300c7de95accb6d3705ee93cb35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac481300c7de95accb6d3705ee93cb35f">&#9670;&nbsp;</a></span>step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classKalman_1_1EKFilter.html#af773d1217ecb01925b857d49b32bc636">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>u_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classKalman_1_1EKFilter.html#af773d1217ecb01925b857d49b32bc636">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>z_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes one prediction-correction step. </p>
<p>This is the main <code><a class="el" href="classKalman_1_1EKFilter.html" title="Generic Extended Kalman Filter (EKF) template base class. ">EKFilter</a></code> function. First, it resizes any matrix who needs it. Then, it proceeds to the time update phase, using the input vector <code>u_</code>. This means that the following virtual functions <em>should be</em> called : <code><a class="el" href="classKalman_1_1EKFilter.html#aace6f213340e7a0c78541454b13e8586" title="Optional function used to precalculate common values for process. ">makeCommonProcess()</a></code>, <code><a class="el" href="classKalman_1_1EKFilter.html#aa2cd9e16f121fe26802a133b4cb37f59" title="Virtual creator of A. ">makeA()</a></code>, <code><a class="el" href="classKalman_1_1EKFilter.html#ac0ea9285a523d219835f7ca2ce932902" title="Virtual creator of W. ">makeW()</a></code>, <code><a class="el" href="classKalman_1_1EKFilter.html#ab9765c4cbe0f67a1aa82ddfbc8173877" title="Virtual creator of Q. ">makeQ()</a></code> and <code><a class="el" href="classKalman_1_1EKFilter.html#a778232d397d981c08b3ca23ea800aa6a" title="Actual process . Fills in new x by using old x. ">makeProcess()</a></code>. At this stage, <em>x</em> contains a current predicted state instead of an old corrected state. If <code>z_</code> is empty, that is, if there are no measures in this step, there is no correction and the function stops there. Else, the measure update phase begins. This means that the following virtual functions <em>should be</em> called : <code><a class="el" href="classKalman_1_1EKFilter.html#a89337cacd8115338ffd34637f0ecbd92" title="Optional function used to precalculate common values for measurement. ">makeCommonMeasure()</a></code>, <code>makeHImpl()</code>, <code>makeVImpl()</code>, <code>makeRImpl()</code>, <code><a class="el" href="classKalman_1_1EKFilter.html#aac9f6d80e5ec9e6ea2ccf045cb682df8" title="Actual measurement function . Fills in z. ">makeMeasure()</a></code> and <code><a class="el" href="classKalman_1_1EKFilter.html#a54a168299879f6b3023b0a42b1afe29d" title="Hook-up function to modify innovation vector. ">makeDZ()</a></code>.After this phase, <em>x</em> contains the new corrected state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u_</td><td>Input vector. Will <b>not</b> be destroyed. Can be empty. </td></tr>
    <tr><td class="paramname">z_</td><td>Measurement vector. Will <b>not</b> be destroyed. Can be empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a715d9c634db18e24579673f426750e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715d9c634db18e24579673f426750e36">&#9670;&nbsp;</a></span>timeUpdateStep()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::timeUpdateStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classKalman_1_1EKFilter.html#af773d1217ecb01925b857d49b32bc636">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>u_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes one prediction step. </p>
<p>This function first resizes any matrix who needs it. Then, it proceeds to the time update phase, using the input vector <code>u_</code>. This means that the following virtual functions <em>should be</em> called : <code><a class="el" href="classKalman_1_1EKFilter.html#aace6f213340e7a0c78541454b13e8586" title="Optional function used to precalculate common values for process. ">makeCommonProcess()</a></code>, <code><a class="el" href="classKalman_1_1EKFilter.html#aa2cd9e16f121fe26802a133b4cb37f59" title="Virtual creator of A. ">makeA()</a></code>, <code><a class="el" href="classKalman_1_1EKFilter.html#ac0ea9285a523d219835f7ca2ce932902" title="Virtual creator of W. ">makeW()</a></code>, <code><a class="el" href="classKalman_1_1EKFilter.html#ab9765c4cbe0f67a1aa82ddfbc8173877" title="Virtual creator of Q. ">makeQ()</a></code> and <code><a class="el" href="classKalman_1_1EKFilter.html#a778232d397d981c08b3ca23ea800aa6a" title="Actual process . Fills in new x by using old x. ">makeProcess()</a></code>. At this stage, <em>x</em> contains a current predicted state instead of an old corrected state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u_</td><td>Input vector. Will <b>not</b> be destroyed. Can be empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a5d936cd96a598b5d8534aeb474012c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d936cd96a598b5d8534aeb474012c5a">&#9670;&nbsp;</a></span>A</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classKalman_1_1EKFilter.html#a7cbc4cb4d9139a7f241b27110426af43">Matrix</a> <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::A</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A jacobian matrix. </p>
<p>This is an <em>n</em> by <em>n</em> jacobian matrix of partial derivatives, defined as follow : </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ A_{[i,j]} = \frac{\partial f_{[i]}}{\partial x_{[j]}} \]" src="form_21.png"/>
</p>
<p> Derived classes should modify it only through <code><a class="el" href="classKalman_1_1EKFilter.html#af3eb4846dcdeaf39ab8f54624588a565" title="Virtual pre-creator of A. ">makeBaseA()</a></code> for the constant part and <code><a class="el" href="classKalman_1_1EKFilter.html#aa2cd9e16f121fe26802a133b4cb37f59" title="Virtual creator of A. ">makeA()</a></code> for the variable part. </p>

</div>
</div>
<a id="af1976aeb370c1741133bf47528ff8e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1976aeb370c1741133bf47528ff8e03">&#9670;&nbsp;</a></span>dz</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classKalman_1_1EKFilter.html#af773d1217ecb01925b857d49b32bc636">Vector</a> <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::dz</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Innovation vector. </p>
<p>This is an <em>m-sized</em> vector. Derived classes should modify it only through <code><a class="el" href="classKalman_1_1EKFilter.html#a54a168299879f6b3023b0a42b1afe29d" title="Hook-up function to modify innovation vector. ">makeDZ()</a></code>. The innovation vector is the difference between the real measurement vector and the predicted one. </p>

</div>
</div>
<a id="ac10c3f39cdcb10bf3bcf30f48efdb48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac10c3f39cdcb10bf3bcf30f48efdb48d">&#9670;&nbsp;</a></span>H</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classKalman_1_1EKFilter.html#a7cbc4cb4d9139a7f241b27110426af43">Matrix</a> <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::H</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A jacobian matrix. </p>
<p>This is an <em>m</em> by <em>n</em> jacobian matrix of partial derivatives, defined as follow : </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ H_{[i,j]} = \frac{\partial h_{[i]}}{\partial x_{[j]}} \]" src="form_23.png"/>
</p>
<p> Derived classes should modify it only through <code><a class="el" href="classKalman_1_1EKFilter.html#a2acc1502881abeb70155762fe3e3a644" title="Virtual pre-creator of H. ">makeBaseH()</a></code> for the constant part and <code><a class="el" href="classKalman_1_1EKFilter.html#a357df3cc6833241d5430c58feaed14ed" title="Virtual creator of H. ">makeH()</a></code> for the variable part. </p>

</div>
</div>
<a id="a1f25e9c8bce9efb50cf3c3a5f3ba6822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f25e9c8bce9efb50cf3c3a5f3ba6822">&#9670;&nbsp;</a></span>Q</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classKalman_1_1EKFilter.html#a7cbc4cb4d9139a7f241b27110426af43">Matrix</a> <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::Q</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process noise covariance matrix. </p>
<p>This is the <em>nw</em> by <em>nw</em> covariance matrix of <em>w</em>, that is : </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ Q = E\left( w w^T \right) \]" src="form_54.png"/>
</p>
<p> Derived classes should modify it only through <code><a class="el" href="classKalman_1_1EKFilter.html#af996b71b5762e8284226a96c6aac8d87" title="Virtual pre-creator of Q. ">makeBaseQ()</a></code> for the constant part and <code><a class="el" href="classKalman_1_1EKFilter.html#ab9765c4cbe0f67a1aa82ddfbc8173877" title="Virtual creator of Q. ">makeQ()</a></code> for the variable part. If <em>Q</em> is always diagonal, then you should turn on the <code>OQ</code> optimization. </p>

</div>
</div>
<a id="ae869345d1d3bb288d87b849556cf7c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae869345d1d3bb288d87b849556cf7c4f">&#9670;&nbsp;</a></span>R</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classKalman_1_1EKFilter.html#a7cbc4cb4d9139a7f241b27110426af43">Matrix</a> <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::R</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Measurement noise covariance matrix. </p>
<p>This is the <em>nv</em> by <em>nv</em> covariance matrix of <em>v</em>, that is : </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ R = E\left( v v^T \right) \]" src="form_55.png"/>
</p>
<p> Derived classes should modify it only through <code><a class="el" href="classKalman_1_1EKFilter.html#adaa2b05e931d64bf8f762812e06ce369" title="Virtual pre-creator of R. ">makeBaseR()</a></code> for the constant part and <code><a class="el" href="classKalman_1_1EKFilter.html#aff7a7f2d08673db1330e04e349b3bb8b" title="Virtual creator of R. ">makeR()</a></code> for the variable part. If both <em>V</em> and <em>R</em> are always diagonal, then you should turn on the <code>OVR</code> optimization. </p>

</div>
</div>
<a id="ad4403db2f52f9a47cd9f432fc44e0a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4403db2f52f9a47cd9f432fc44e0a5d">&#9670;&nbsp;</a></span>u</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classKalman_1_1EKFilter.html#af773d1217ecb01925b857d49b32bc636">Vector</a> <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::u</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input vector. </p>
<p>This is an <em>nu-sized</em> vector. Derived classes should never modify it. </p>

</div>
</div>
<a id="a9289999f22782549b25b67c4ae81b1c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9289999f22782549b25b67c4ae81b1c5">&#9670;&nbsp;</a></span>V</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classKalman_1_1EKFilter.html#a7cbc4cb4d9139a7f241b27110426af43">Matrix</a> <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::V</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A jacobian matrix. </p>
<p>This is an <em>m</em> by <em>nv</em> jacobian matrix of partial derivatives, defined as follow : </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ V_{[i,j]} = \frac{\partial h_{[i]}}{\partial v_{[j]}} \]" src="form_24.png"/>
</p>
<p> Derived classes should modify it only through <code><a class="el" href="classKalman_1_1EKFilter.html#a72e6e032ae5db155eb7d1ba1401db9be" title="Virtual pre-creator of V. ">makeBaseV()</a></code> for the constant part and <code><a class="el" href="classKalman_1_1EKFilter.html#a70bb019d226cbf9858954b81c89392a7" title="Virtual creator of V. ">makeV()</a></code> for the variable part. If both V and R are always diagonal, then you should turn on the <code>OVR</code> optimization. </p>

</div>
</div>
<a id="a3a50c13fef614d595d01afa70184db84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a50c13fef614d595d01afa70184db84">&#9670;&nbsp;</a></span>W</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classKalman_1_1EKFilter.html#a7cbc4cb4d9139a7f241b27110426af43">Matrix</a> <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::W</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A jacobian matrix. </p>
<p>This is an <em>n</em> by <em>nw</em> jacobian matrix of partial derivatives, defined as follow : </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ W_{[i,j]} = \frac{\partial f_{[i]}}{\partial w_{[j]}} \]" src="form_22.png"/>
</p>
<p> Derived classes should modify it only through <code><a class="el" href="classKalman_1_1EKFilter.html#a6668b0ffe41e701cc44337546d233465" title="Virtual pre-creator of W. ">makeBaseW()</a></code> for the constant part and <code><a class="el" href="classKalman_1_1EKFilter.html#ac0ea9285a523d219835f7ca2ce932902" title="Virtual creator of W. ">makeW()</a></code> for the variable part. </p>

</div>
</div>
<a id="abc9456e14fd29b7c82ad901ab3e4e63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9456e14fd29b7c82ad901ab3e4e63f">&#9670;&nbsp;</a></span>x</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classKalman_1_1EKFilter.html#af773d1217ecb01925b857d49b32bc636">Vector</a> <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::x</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Corrected state vector. </p>
<p>This is an <em>n-sized</em> vector. Derived classes should modify it only through <code><a class="el" href="classKalman_1_1EKFilter.html#a778232d397d981c08b3ca23ea800aa6a" title="Actual process . Fills in new x by using old x. ">makeProcess()</a></code>. </p>

</div>
</div>
<a id="a91baacb49f7fae74c449c1d21424f126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91baacb49f7fae74c449c1d21424f126">&#9670;&nbsp;</a></span>z</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classKalman_1_1EKFilter.html#af773d1217ecb01925b857d49b32bc636">Vector</a> <a class="el" href="classKalman_1_1EKFilter.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::z</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicted measurement vector. </p>
<p>This is an <em>m-sized</em> vector. Derived classes should modify it only through <code><a class="el" href="classKalman_1_1EKFilter.html#aac9f6d80e5ec9e6ea2ccf045cb682df8" title="Actual measurement function . Fills in z. ">makeMeasure()</a></code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/vlad/projects/brainhub/gestusSDK/inc/kalman/<a class="el" href="ekfilter_8hpp_source.html">ekfilter.hpp</a></li>
<li>/home/vlad/projects/brainhub/gestusSDK/inc/kalman/<a class="el" href="ekfilter__impl_8hpp_source.html">ekfilter_impl.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
