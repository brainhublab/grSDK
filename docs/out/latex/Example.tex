\label{Example_expage}%
\Hypertarget{Example_expage}%
\hypertarget{Example_example}{}\section{How to Use this Extended Kalman Filter Library?}\label{Example_example}
\hypertarget{Example_introduction}{}\subsection{Introduction}\label{Example_introduction}
This Extended Kalman Filter library is powerful and very simple to use, but a Kalman filter is very difficult to debug. So, it is very important to follow a procedure to be sure that everything is right (code and equations). This example suggests a procedure to follow and shows how to use the library. If you are not familiar with the Kalman filter, please read this article \mbox{[}02\mbox{]}.\hypertarget{Example_step1}{}\subsection{Step 1 \+: Find the mathematical model of the system}\label{Example_step1}
The first thing to do is to find out the state vector you want to estimate $ \vec x $ and the inputs $ \vec u $ of the system. After this, find the non-\/linear process function $ f $ that describes the evolution of the state vector through time, that is \+: \[ \vec x_k = f \left( x_{k-1}, u_{k-1}, w_{k-1} \right) \] where $ w $ is the process noise vector due to uncertainty and process modeling errors.

Then, find the non-\/linear relation between your state vector $ \vec x $ and the measure vector $ \vec z $. \[ \vec z_k = h \left( x_{k-1}, v_{k-1} \right) \] where $ v $ is the measure noise vector.

\begin{DoxyParagraph}{In this example \+:}

\end{DoxyParagraph}
A plane flies in a 2D space where the x axis is the distance traveled by the plane and y axis is its altitude. This system can be represented by the following continuous equations\+:

\[ \ddot x = \frac{u}{m} - \frac{b_x}{m} \dot x^{2} \] \[ \ddot y = \frac{p}{m} \dot x^{2} - g \]

where $ m $ is the plane\textquotesingle{}s weight (1000 kg)~\newline
 $ b_{x} $ is the drag coefficient (0.\+35 N/m²/s²)~\newline
 $ p $ is the lift force (3.\+92 N/m²/s²)~\newline
 $ g $ is the gravitational acceleration (9.\+8 m/s²)~\newline
 $ u $ (the input) is the motor\textquotesingle{}s thrust~\newline
 The discrete equation is\+: \[\vec x_k = \left [ \begin{array}{c} x_k \\ \\ \dot x_k \\ \\ y_k \\ \\ \dot y_k \end{array} \right] = //! \left [ \begin{array}{c} //! x_{k-1} + T \dot x_{k-1} + \frac{T^{2}}{2} \left( \frac{u}{m} - \frac{b_x}{m} \dot x_{k-1}^{2} \right )\\ \\ //! \dot x_{k-1} + T \left ( \frac{u}{m} - \frac{b_x}{m} \dot x_{k-1}^{2} \right ) + w_{1} \\ \\ //! y_{k-1} + T \dot y_{k-1} + \frac{T^{2}}{2} \left( \frac{p}{m} \dot x_{k-1}^{2} - g \right )\\ \\ //! \dot y_{k-1} + T \left( \frac{p}{m} \dot x_{k-1}^{2} - g \right ) + w_{2} //! \end{array} \right ] \]

where $ w_{1} $ and $ w_{2} $ are the random variables which represent the process noise.

A station on the ground (at the origin) mesures the angle between the plane and the ground (x axis) and the distance between the plane and the station. These measures are based on the following equation\+:

\[\vec z_k = \left [ \begin{array}{c} \theta \\ \\ r \end{array} \right ] = //! \left [ \begin{array}{c} atan(\frac{y}{x}) +v_{1} \\ \\ \sqrt{x^{2}+y^{2}} + v_{2} \end{array} \right ] \]

where $ v_{1} $ and $ v_{2} $ are the random variables which represent the process noise.\hypertarget{Example_step2}{}\subsection{Step 2 \+: Calculate Jacobian matrix}\label{Example_step2}
Calculate the jacobian matrix A, W, H and V where \+: A is an {\itshape n} by {\itshape n} jacobian matrix of partial derivatives, defined as follow \+: \[ A_{[i,j]} = \frac{\partial f_{[i]}}{\partial x_{[j]}} \]

W is an {\itshape n} by {\itshape nv} jacobian matrix of partial derivatives, defined as follow \+: \[ W_{[i,j]} = \frac{\partial f_{[i]}}{\partial w_{[j]}} \]

H is an {\itshape m} by {\itshape n} jacobian matrix of partial derivatives, defined as follow \+: \[ H_{[i,j]} = \frac{\partial h_{[i]}}{\partial x_{[j]}} \]

V is an {\itshape m} by {\itshape nv} jacobian matrix of partial derivatives, defined as follow \+: \[ V_{[i,j]} = \frac{\partial h_{[i]}}{\partial v_{[j]}} \]

$ n $ is the number of element in state vector~\newline
 $ m $ is the number of measure~\newline
 $ nw $ is the number of process noise random variables~\newline
 $ nv $ is the number of measure noise random variables~\newline
 \begin{DoxyParagraph}{In this example\+:}

\end{DoxyParagraph}
\[ A = \left [ \begin{array}{cccc} //! 1 & T-T^{2} \frac{b}{m} \dot x_{k-1} & 0 & 0 \\ \\ //! 0 & 1-2T \frac{b}{m} \dot x_{k-1} & 0 & 0 \\ \\ //! 0 & T^{2} \frac{p}{m} \dot x_{k-1} & 1 & T \\ \\ //! 0 & 2T \frac{p}{m} \dot x_{k-1} & 0 & 1 //! \end{array} \right ] \]

\[ W = \left [ \begin{array}{cc} //! 0 & 0 \\ \\ //! 1 & 0 \\ \\ //! 0 & 0\\ \\ //! 0 & 1 //! \end{array} \right ] \]

\[ H = \left [ \begin{array}{cccc} //! \frac{- \dot y_{k-1}}{x_{k-1}^{2}+y_{k-1}^{2}} & 0 \frac{ \dot x_{k-1}}{x_{k-1}^{2}+y_{k-1}^{2}} & 0 \\ \\ //! \frac{ \dot x_{k-1}}{\sqrt{x_{k-1}^{2}+y_{k-1}^{2}}} & 0 \frac{ \dot y_{k-1}}{\sqrt{x_{k-1}^{2}+y_{k-1}^{2}}} & 0 //! \end{array} \right ] \]

\[ V = \left [ \begin{array}{cc} //! 1 & 0 \\ \\ //! 0 & 1 //! \end{array} \right ] \]\hypertarget{Example_step3}{}\subsection{Step 3 \+: Initial conditions and covariance matrix}\label{Example_step3}
\begin{DoxyVerb}Set initial estimation of the state vector. After, set the covariance matrix P 
which represents the covariance of the error of the state vector estimation. 
Then, set the covariance Q and R which represent the covariance matrix
of process noise and measurement noise, respectively.

\par In this example:

The first estimation of the state vector is based on the first measures and the covariance matrix are the following:
\end{DoxyVerb}


\[\vec x = \left [ \begin{array}{c} r\cos\theta \\ 60 \\ r\sin\theta \\ 0 \end{array} \right] \]

\[ P = \left [ \begin{array}{cccc} //! 100^2 & 0 & 0 & 0 \\ \\ //! 0 & 10^2 & 0 & 0 \\ \\ //! 0 & 0 & 25^2 & 0 \\ \\ //! 0 & 0 & 0 & 10^2 \\ \\ //! \end{array} \right ] \]

\[ Q = \left [ \begin{array}{cc} //! 0.01^{2} & 0.01^{2}/10 \\ \\ //! 0.01^{2}/10 & 0.01^{2} //! \end{array} \right ] \]

\[ R = \left [ \begin{array}{cc} //! 0.01^{2} & 0 \\ \\ //! 0 & 0.01^{2} //! \end{array} \right ] \]\hypertarget{Example_step4}{}\subsection{Step 4 \+: Implementation of the Kalman filter}\label{Example_step4}
\begin{DoxyVerb}Now, it's time to create the first version of your %Kalman filter. 
You should not try to optimize it at this step, just create your filter and validate it.
This library allows you to optimize your filter, but in your first implementation, 
code only the basic functions.  So, code functions called \c makeProcess(), \c makeMeasure(), 
\c makeA(), \c makeH(), \c makeQ(), \c makeR(), \c makeV() and \c makeW(). These functions will set the value of each matrix.

The first thing to do is to create your %Kalman filter class.

\dontinclude simple_plane.h
\skip class
\until }

In this example, our %Kalman filter inherits from the Extended %Kalman Filter, because it's a non-linear problem ( \form#2 and \form#36 are non-linear functions)
The first two template parameters are respectively the floating point type used by the filter (\c float or \c double) and the beginning index
of vectors and matrices (0 or 1). There are three other template parameters to the \c EKFilter template class. 
They are explained in the next section, but they
can be safely set to their default values in the first version of the filter, which are false, false and true to 
disable optimizations and enable bound-checking.

You should declare each functions named previously in this class. You can declare variables too.

After, code the class constructor. You can call the function \c setDim() here or you will call it manually
in your \c main() function after you created the filter object.  The function \c setDim() sets the number of states,
the number of inputs, the number of process noise random variables, the number of measures and the 
number of measurement noise random variables. It can be used by advanced users to implement a
Variable-Dimension Extended %Kalman Filter (an EKF whose dimensions may change from one iteration to the other).

\dontinclude simple_plane.cpp
\skip cPlaneEKF::cPlaneEKF
\until }

In the function \c makeProcess(), you should use a temporary vector to store the new state vector like this :

\skip cPlaneEKF::makeProcess
\until }

In the function \c makeMeasure(), you update directly the measures vector \form#5.  These are the predicted measures.

\skip cPlaneEKF::makeMeasure
\until }

Then, you code all other functions \c makeX() like this:

\dontinclude simple_plane.cpp
\skip cPlaneEKF::makeA
\until }

\skip cPlaneEKF::makeW
\until }

\skip cPlaneEKF::makeQ
\until }

\skip cPlaneEKF::makeH
\until }

\skip cPlaneEKF::makeV
\until }

\skip cPlaneEKF::makeR
\until }

Now, your filter is ready to be used.  In this example, the measures and the inputs
have been calculated by the \c generation.m Matlab script. It's a good idea to test 
your filter with fixed measures and inputs if you want to validate it.

After you create the filter object, you should call the \c setDim() function before calling the \c init() function.
In this example, the \c setDim() function is called in the class constructor.  The \c init() function 
sets the initial state and the initial covariance matrix. 

WARNING : The vectors passed to the \c init() function become unusable when \c init() returns ! Never use those vectors after the call.

\dontinclude example.cpp
\skip cPlaneEKF
\until };

\skip Initial
\until init

\skip for
\until }

Call the function \c step() for each iteration and pass the new inputs and the new measures. 
\end{DoxyVerb}
\hypertarget{Example_step5}{}\subsection{Step 5 \+: Optimization}\label{Example_step5}
\begin{DoxyVerb}When your %Kalman filter works properly, you can optimize it in many simple ways.

-# If matrix Q is always diagonal, set the OQ template parameter to \c true. This will
minimize some calculations. Also, you will only need to fill in diagonal elements of Q,
since the other values will never be read.
-# If both matrices V and R are always diagonal, set the OVR template parameter to \c true. This will
minimize some calculations. Also, you will only need to fill in diagonal elements of V and R,
since the other values will never be read.
-# If some matrix values are constant, use the \c makeBaseX() function instead of the \c makeX() function
to fill these values.
These functions are called only once at the beginning instead of once per iteration. You can used 
the \c makeBaseX() function to set values that never change in a matrix and just set the other
values in the \c makeX() function.
-# If complex calculations are needed for more than one of \c makeA(), \c makeW(), \c makeQ() and \c makeProcess()
functions, then use the function \c makeCommonProcess() to do those calculations and save them in member variables of your own subclass.  This function is
always called before the others.
-# If complex calculations are needed for more than one of \c makeH(), \c makeV(), \c makeR(), \c makeMeasure()
and \c makeDZ() functions, then use the function \c makeCommonMeasure() to do those calculations and save them in member variables of your own subclass.  This function is
always called before the others.
-# While writing a \c makeX() or a \c makeBaseX() function, there can be some execution paths where the function
does not modify any matrix (for example, if there is some condition, then modify the matrix, else don't).
If this is the case, then each non-mutating execution path should call \c NoModification() before returning,
so that some calculations can be avoided.
-# When your filter works properly, set the debug template parameter to \c false to disable bound-checking.

\par In this example:

This example have been optimized in many ways:

- The matrices V and R are diagonal, so the OVR template parameter is set to true.  Then, we just have to 
set the diagonal values of those matrices.
- The matrices V, R, W and Q never change, so we use \c makeBaseX() functions instead of \c makeX() functions.
- Constants values of A and H have been moved from the \c makeX() functions to \c makeBaseX() functions.
- The filter works properly, so we don't need bound-checking. Let's set the debug template parameter to \c false.

So, the final result for this example is:

\include plane.h

\include plane.cpp
\end{DoxyVerb}
\hypertarget{Example_reference}{}\section{References}\label{Example_reference}
\mbox{[}01\mbox{]} Bierman, G. J. \char`\"{}\+Factorization Methods for Discrete Sequential
    Estimation\char`\"{}, Academic Press, 1977. ~\newline
 \mbox{[}02\mbox{]} Welch, G. and Bishop, G. \char`\"{}\+An Introduction to the \%\+Kalman Filter\char`\"{}, \href{http://www.cs.unc.edu/~welch/kalman/kalmanIntro.html}{\tt http\+://www.\+cs.\+unc.\+edu/$\sim$welch/kalman/kalman\+Intro.\+html} 